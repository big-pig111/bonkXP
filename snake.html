<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Meme Snake Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-functions-compat.js"></script>
    
    <!-- Background Music -->
    <audio id="bgMusic" loop>
        <source src="1.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
    <!-- Sound Effects -->
    <audio id="eatSound" preload="auto">
        <source src="2.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <style type="text/tailwindcss">
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        .font-meme {
            font-family: 'Orbitron', monospace;
        }
        
        .text-memeRed { color: #FF3333; }
        .text-memeBlue { color: #0066FF; }
        .text-memeGreen { color: #33CC33; }
        .text-memeYellow { color: #FFE100; }
        .text-memePink { color: #FF66CC; }
        
        .bg-memeRed { background-color: #FF3333; }
        .bg-memeBlue { background-color: #0066FF; }
        .bg-memeGreen { background-color: #33CC33; }
        .bg-memeYellow { background-color: #FFE100; }
        .bg-memePink { background-color: #FF66CC; }
        
        .border-memeRed { border-color: #FF3333; }
        .border-memeBlue { border-color: #0066FF; }
        .border-memeGreen { border-color: #33CC33; }
        .border-memeYellow { border-color: #FFE100; }
        .border-memePink { border-color: #FF66CC; }
        
        .hover\:bg-memeRed:hover { background-color: #FF3333; }
        .hover\:bg-memeBlue:hover { background-color: #0066FF; }
        .hover\:bg-memeGreen:hover { background-color: #33CC33; }
        .hover\:bg-memeYellow:hover { background-color: #FFE100; }
        .hover\:bg-memePink:hover { background-color: #FF66CC; }
        
        .bounce-meme {
            animation: bounce 1s infinite;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }
        
        .pulse-meme {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }
        
        /* Music Control Floating Window Styles */
        .music-control {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #FFE100;
            border-radius: 15px;
            padding: 10px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .music-control:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 225, 0, 0.5);
        }
        
        .music-btn {
            background: linear-gradient(45deg, #FFE100, #FF9900);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            color: #000;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .music-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 225, 0, 0.7);
        }
        
        .music-btn.muted {
            background: linear-gradient(45deg, #666, #999);
            color: #fff;
        }
        
        .music-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 15px;
            height: 15px;
            background: #33CC33;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        
        .music-indicator.muted {
            background: #FF3333;
            animation: none;
        }
    </style>
</head>
<body class="bg-gray-900 font-meme min-h-screen flex flex-col items-center justify-center p-4 text-white overflow-x-hidden">
    
    <!-- Music Control Floating Window -->
    <div class="music-control" id="musicControl">
        <div class="music-indicator" id="musicIndicator"></div>
        <button class="music-btn" id="musicBtn" title="Toggle Music">
            <i class="fa fa-music"></i>
        </button>
    </div>
    <!-- Page Title -->
    <header class="text-center mb-6 relative">
        <h1 class="text-[clamp(2rem,5vw,4rem)] font-bold text-memeYellow glow mb-2 transform -rotate-2">
            <i class="fa fa-users mr-2"></i> Multiplayer MEME Snake <i class="fa fa-users ml-2"></i>
        </h1>
        <p class="text-memePink text-[clamp(1rem,2vw,1.5rem)] wiggle">
            Eat together, grow together with friends!
        </p>
    </header>

         <!-- Game Container -->
             <main class="relative w-full max-w-7xl">
        <!-- Player Info and Score Panel -->
        <div class="flex flex-wrap justify-between items-center mb-4 gap-4">
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-user text-memeBlue mr-2"></i>
                    <span class="text-xl">Player: <span id="playerName" class="text-memeGreen font-bold">Anonymous</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-star text-memeYellow mr-2"></i>
                    <span class="text-xl">Score: <span id="score" class="text-memeGreen font-bold">0</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-users text-memePink mr-2"></i>
                    <span class="text-xl">Online: <span id="playerCount" class="text-memeBlue font-bold">0</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-gamepad text-memeRed mr-2"></i>
                    <span class="text-xl">Room: <span id="roomName" class="text-memeBlue font-bold">Default Room</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-clock text-memePink mr-2"></i>
                    <span class="text-xl" id="countdown">Next Reset: --:--</span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeGreen flex-1 min-w-[200px]">
                <div class="flex items-center justify-between">
                    <div class="flex items-center">
                        <i class="fa fa-gift text-memeGreen mr-2"></i>
                        <span class="text-xl">My Points</span>
                    </div>
                    <button id="claimRewardBtn" class="bg-memeGreen hover:bg-memeGreen/80 text-black px-3 py-1 rounded text-sm font-bold">
                        Claim Rewards
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Game Canvas Container -->
        <div class="relative border-4 border-memePink rounded-lg overflow-hidden bg-gray-800 shadow-lg">
            <canvas id="gameCanvas" class="w-full h-auto bg-gray-900"></canvas>
            
            <!-- Start Screen -->
            <div id="startScreen" class="absolute inset-0 bg-gray-900/90 flex flex-col items-center justify-center z-10">
                <h2 class="text-4xl font-bold text-memeYellow mb-6 bounce-meme">Ready to play with friends?</h2>
                <div class="mb-4 w-full max-w-xs">
                    <label for="playerNameInput" class="block text-left mb-2 text-memeGreen">Your Wallet Address</label>
                    <input type="text" id="playerNameInput" 
                           class="w-full bg-gray-700 border border-memeBlue rounded p-2 text-white font-meme"
                           placeholder="Enter your Solana wallet address">
                </div>
                <div class="mb-4 w-full max-w-xs">
                    <label for="roomSelect" class="block text-left mb-2 text-memeBlue">Select Room</label>
                    <select id="roomSelect" class="w-full bg-gray-700 border border-memeBlue rounded p-2 text-white font-meme">
                        <option value="default">Default Room</option>
                        <option value="room1">Room 1 - Beginner</option>
                        <option value="room2">Room 2 - Advanced</option>
                        <option value="room3">Room 3 - Casual</option>
                    </select>
                </div>
                <div class="mb-6 w-full max-w-xs">
                    <label class="block text-left mb-2 text-memePink">Choose Color</label>
                    <div class="flex gap-2 flex-wrap">
                        <button class="color-btn w-8 h-8 rounded-full bg-memeRed border-2 border-white" data-color="#FF3333"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memeBlue border-2" data-color="#0066FF"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memeGreen border-2" data-color="#33CC33"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memeYellow border-2" data-color="#FFE100"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memePink border-2" data-color="#FF66CC"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-orange-500 border-2" data-color="#FF9900"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-purple-500 border-2" data-color="#9966FF"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-cyan-500 border-2" data-color="#66CCFF"></button>
                    </div>
                </div>
                <button id="startBtn" class="bg-memeRed hover:bg-memeRed/80 text-white text-2xl py-3 px-8 rounded-full transform transition-transform hover:scale-110 active:scale-95 font-bold shadow-lg">
                    Join Game <i class="fa fa-play ml-2"></i>
                </button>
            </div>
            
            <!-- Game Over Screen -->
            <div id="gameOverScreen" class="absolute inset-0 bg-gray-900/95 flex flex-col items-center justify-center z-10 hidden">
                <h2 class="text-5xl font-bold text-memeRed mb-4 wiggle">Game Over!</h2>
                <p class="text-2xl mb-2">Your Score: <span id="finalScore" class="text-memeGreen font-bold">0</span></p>
                <p class="text-xl mb-4">Leaderboard:</p>
                <ul id="leaderboard" class="mb-8 bg-gray-800 p-4 rounded-lg w-64">
                    <!-- Leaderboard will be generated here -->
                </ul>
                <button id="restartBtn" class="bg-memeGreen hover:bg-memeGreen/80 text-white text-2xl py-3 px-8 rounded-full transform transition-transform hover:scale-110 active:scale-95 font-bold shadow-lg">
                    Play Again <i class="fa fa-refresh ml-2"></i>
                </button>
            </div>
            
            <!-- Pause Button -->
            <button id="pauseBtn" class="absolute top-4 right-4 bg-gray-800/70 hover:bg-gray-700 text-white p-2 rounded-full z-5 hidden">
                <i class="fa fa-pause text-xl"></i>
            </button>
            
            <!-- Room Switch Button -->
            <button id="roomSwitchBtn" class="absolute top-4 left-4 bg-gray-800/70 hover:bg-gray-700 text-white p-2 rounded-full z-5 hidden">
                <i class="fa fa-exchange text-xl"></i>
            </button>
            
            <!-- Claim Rewards Modal -->
            <div id="claimRewardModal" class="absolute inset-0 bg-gray-900/95 flex items-center justify-center z-20 hidden">
                <div class="bg-gray-800 p-6 rounded-lg border-2 border-memeGreen max-w-md w-full mx-4">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-2xl font-bold text-memeGreen">Claim Rewards</h3>
                        <button id="closeClaimModal" class="text-gray-400 hover:text-white text-xl">
                            <i class="fa fa-times"></i>
                        </button>
                    </div>
                    
                    <div class="mb-4">
                        <label for="walletAddressInput" class="block text-left mb-2 text-memeBlue">Wallet Address</label>
                        <input type="text" id="walletAddressInput" 
                               class="w-full bg-gray-700 border border-memeBlue rounded p-2 text-white font-meme"
                               placeholder="Enter your Solana wallet address">
                    </div>
                    
                    <div class="mb-4 p-3 bg-gray-700 rounded">
                        <div class="text-center">
                            <div class="text-3xl font-bold text-memeYellow" id="totalScore">0</div>
                            <div class="text-sm text-gray-400">Total Points</div>
                        </div>
                    </div>
                    
                    <div class="mb-4 p-3 bg-gray-700 rounded">
                        <div class="text-center">
                            <div class="text-lg font-bold text-memeGreen" id="tokenAmount">0</div>
                            <div class="text-sm text-gray-400">Tokens Available</div>
                        </div>
                    </div>
                    
                    <div class="flex gap-2 mb-4">
                        <button id="checkScoreBtn" class="flex-1 bg-memeBlue hover:bg-memeBlue/80 text-white py-2 px-4 rounded font-bold">
                            Check Points
                        </button>
                        <button id="claimTokenBtn" class="flex-1 bg-memeGreen hover:bg-memeGreen/80 text-black py-2 px-4 rounded font-bold">
                            Claim Tokens
                        </button>
                    </div>
                    
                    <div class="flex gap-2">
                        <button id="viewLeaderboardBtn" class="flex-1 bg-memePink hover:bg-memePink/80 text-white py-2 px-4 rounded font-bold">
                            <i class="fa fa-trophy mr-2"></i>Global Leaderboard
                        </button>
                    </div>
                    
                    <div id="claimResult" class="mt-4 p-3 rounded hidden">
                        <!-- Result display area -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Global Leaderboard Modal -->
        <div id="leaderboardModal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50 hidden">
            <div class="bg-gray-800 p-6 rounded-lg border-2 border-memePink max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-2xl font-bold text-memePink">
                        <i class="fa fa-trophy mr-2"></i>Global Leaderboard
                    </h3>
                    <button id="closeLeaderboardModal" class="text-gray-400 hover:text-white text-xl">
                        <i class="fa fa-times"></i>
                    </button>
                </div>
                
                <div class="mb-4">
                    <div class="flex gap-2 mb-4">
                        <select id="leaderboardRoomSelect" class="flex-1 bg-gray-700 border border-memePink rounded p-2 text-white">
                            <option value="all">All Rooms</option>
                            <option value="default">Default Room</option>
                            <option value="room1">Room 1 - Beginner</option>
                            <option value="room2">Room 2 - Advanced</option>
                            <option value="room3">Room 3 - Casual</option>
                        </select>
                        <button id="refreshLeaderboardBtn" class="bg-memePink hover:bg-memePink/80 text-white py-2 px-4 rounded font-bold">
                            <i class="fa fa-refresh mr-2"></i>Refresh
                        </button>
                    </div>
                </div>
                
                <div class="bg-gray-700 rounded p-4">
                    <div class="grid grid-cols-4 gap-4 mb-4 text-center text-sm font-bold text-memePink">
                        <div>Rank</div>
                        <div>Player</div>
                        <div>Score</div>
                        <div>Date</div>
                    </div>
                    <div id="globalLeaderboardList" class="space-y-2">
                        <!-- Leaderboard entries will be loaded here -->
                    </div>
                </div>
                
                <div class="mt-4 text-center text-sm text-gray-400">
                    <p>ğŸ† Top players across all rooms</p>
                    <p>ğŸ’ Scores are updated in real-time</p>
                </div>
            </div>
        </div>
        
        <!-- Game Controls and Player List -->
        <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div class="bg-gray-800 p-4 rounded-lg border border-memeBlue">
                <h3 class="text-memeBlue text-xl font-bold mb-2">Game Instructions</h3>
                <ul class="list-disc pl-5 space-y-1">
                    <li>Eat food to make the snake longer</li>
                    <li>Hitting walls, yourself, or other players will cause death</li>
                    <li>Higher scores mean faster speed</li>
                    <li>Special foods have surprises!</li>
                    <li>Press Space to pause/continue</li>
                </ul>
            </div>
            <div class="bg-gray-800 p-4 rounded-lg border border-memeGreen">
                <h3 class="text-memeGreen text-xl font-bold mb-2">Current Players</h3>
                <ul id="playersList" class="space-y-2 max-h-32 overflow-y-auto">
                    <!-- Player list will be generated here -->
                </ul>
            </div>
        </div>
        
        <!-- Room Statistics -->
        <div class="mt-4 bg-gray-800 p-4 rounded-lg border border-memeYellow">
            <h3 class="text-memeYellow text-xl font-bold mb-2">Room Statistics</h3>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="text-center">
                    <div class="text-2xl font-bold text-memeGreen" id="totalPlayers">0</div>
                    <div class="text-sm text-gray-400">Total Players</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-memeBlue" id="activePlayers">0</div>
                    <div class="text-sm text-gray-400">Active Players</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-memeRed" id="roomHighScore">0</div>
                    <div class="text-sm text-gray-400">Room High Score</div>
                </div>
            </div>
        </div>
        

    </main>
    
    <!-- Footer -->
    <footer class="mt-8 text-center text-gray-500 text-sm">
        <p>Â© 2023 Multiplayer Meme Snake | Real-time sync with Firebase <i class="fa fa-bolt text-memeYellow"></i></p>
    </footer>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyA5Z5ieEbAcfQX0kxGSn9ldGXhzvAwx_8M",
            authDomain: "chat-294cc.firebaseapp.com",
            databaseURL: "https://chat-294cc-default-rtdb.firebaseio.com",
            projectId: "chat-294cc",
            storageBucket: "chat-294cc.firebasestorage.app",
            messagingSenderId: "913615304269",
            appId: "1:913615304269:web:0274ffaccb8e6b678e4e04",
            measurementId: "G-SJR9NDW86B"
        };

        // Initialize Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const functions = firebase.functions();
        
        // Game Constants and Variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const playerCountElement = document.getElementById('playerCount');
        const playerNameElement = document.getElementById('playerName');
        const finalScoreElement = document.getElementById('finalScore');
        const leaderboardElement = document.getElementById('leaderboard');
        const playersListElement = document.getElementById('playersList');
        const roomNameElement = document.getElementById('roomName');
        const totalPlayersElement = document.getElementById('totalPlayers');
        const activePlayersElement = document.getElementById('activePlayers');
        const roomHighScoreElement = document.getElementById('roomHighScore');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const roomSwitchBtn = document.getElementById('roomSwitchBtn');
        const playerNameInput = document.getElementById('playerNameInput');
        const roomSelect = document.getElementById('roomSelect');
        
        // Music Control Elements
        const bgMusic = document.getElementById('bgMusic');
        const musicBtn = document.getElementById('musicBtn');
        const musicIndicator = document.getElementById('musicIndicator');
        let isMusicPlaying = false;
        let musicVolume = 0.5;
        
        // Sound Effects Elements
        const eatSound = document.getElementById('eatSound');
        let soundVolume = 0.7;
        
                // Game State Variables
        let playerId = null;
        let playerWallet = ''; // Player wallet address
        let playerName = 'Anonymous';
        let snake = [];
        let otherPlayers = {};
        let foods = []; // Changed to array to store multiple foods
        let specialFood = null;
        let corpseFoods = []; // Dead player's snake body becomes food
        let direction = '';
        let nextDirection = '';
        let score = 0;
        let level = 1;
        let gameSpeed = 100; // milliseconds, slightly faster to adapt to larger game area
        let gameLoop;
        let isGameRunning = false;
        let isPaused = false;
        let gameRoom = 'default'; // Game room
        let playerColor = '';
        let playerAvatar = '';
        let gameMargin = 0; // Game margin (border)
        const MAX_FOODS = 5; // Maximum number of foods on field
        
        // Firebase Functions Reference
        const claimTokenFunction = firebase.functions().httpsCallable('claimToken');
        
        // Image Resources
        let snakeHeadImage = null;
        let snakeBodyImage = null;
        let snakeTailImage = null;
                  let foodImage = null;
          let corpseImage = null;
          let snakeTurnEImage = null;  // å³ä¸‹è½¬å¼¯
          let snakeTurnQImage = null;  // å·¦ä¸‹è½¬å¼¯
          let snakeTurnRImage = null;  // å·¦ä¸Šè½¬å¼¯
          let snakeTurnWImage = null;  // å³ä¸Šè½¬å¼¯
          let imagesLoaded = 0;
          const totalImages = 9;
        
        // Meme elements
        const memeFaces = ['(â—â€¢á´—â€¢â—)', '(Â¬â€¿Â¬)', '(Ê˜â€¿Ê˜)', '(â—”_â—”)', '(Â°ãƒ­Â°)'];
        const memeColors = [
            '#FFE100', '#0066FF', '#FF3333', '#33CC33', '#FF66CC',
            '#FF9900', '#9966FF', '#66CCFF', '#FF6666', '#99FF66'
        ];
        
                         // Set Canvas Size
        function resizeCanvas() {
            const container = canvas.parentElement;
            // Use fixed canvas size to ensure all players see the same map
            canvas.width = 1200; // Fixed width 1200px
            canvas.height = 960; // Fixed height 960px, maintain 5:4 ratio
            
            // Calculate margin (border)
            const margin = Math.floor(canvas.width * 0.05); // 5% margin
            gameMargin = margin;
        }
        
        // Load image resources
        function loadImages() {
            snakeHeadImage = new Image();
            snakeBodyImage = new Image();
            snakeTailImage = new Image();
            foodImage = new Image();
            corpseImage = new Image();
            snakeTurnEImage = new Image();
            snakeTurnQImage = new Image();
            snakeTurnRImage = new Image();
            snakeTurnWImage = new Image();
            
            snakeHeadImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeBodyImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeTailImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            foodImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            corpseImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeTurnEImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeTurnQImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeTurnRImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeTurnWImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeHeadImage.src = 'png/snake1.png';
            snakeBodyImage.src = 'png/snake.png';
            snakeTailImage.src = 'png/snake4.png';
            foodImage.src = 'png/snake2.png';
            corpseImage.src = 'png/snake3.png';
            snakeTurnEImage.src = 'png/e.png';     // å³ä¸‹è½¬å¼¯
            snakeTurnQImage.src = 'png/q.png';     // å·¦ä¸‹è½¬å¼¯
            snakeTurnRImage.src = 'png/r.png';     // å·¦ä¸Šè½¬å¼¯
            snakeTurnWImage.src = 'png/w.png';     // å³ä¸Šè½¬å¼¯
        }
        
        // Initialize canvas size and listen for window resize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Load images
        loadImages();
        
        // Generate unique player ID
        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substring(2, 10);
        }
        
        // Initialize Game
        function initGame() {
            // Get player wallet address and room
            if (playerNameInput.value.trim()) {
                playerWallet = playerNameInput.value.trim();
                playerName = playerWallet.substring(0, 8) + '...' + playerWallet.substring(playerWallet.length - 4);
            } else {
                alert('Please enter a valid wallet address!');
                return;
            }
            
            // Validate wallet address format (simple Solana address validation)
            if (!playerWallet.match(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)) {
                alert('Please enter a valid Solana wallet address!');
                return;
            }
            
            // Use wallet address as player ID
            playerId = playerWallet;
            gameRoom = roomSelect.value;
            playerNameElement.textContent = playerName;
            
            // Update room name display
            const roomNames = {
                'default': 'Default Room',
                'room1': 'Room 1 - Beginner',
                'room2': 'Room 2 - Advanced',
                'room3': 'Room 3 - Casual'
            };
            roomNameElement.textContent = roomNames[gameRoom] || 'Default Room';
            
                                     // Set initial snake position
            const gridSize = 15; // Fixed grid size
            
            // Calculate effective game area using fixed canvas size
            const canvasWidth = 1200;
            const canvasHeight = 960;
            const margin = Math.floor(canvasWidth * 0.05); // 60px margin
            const effectiveWidth = canvasWidth - 2 * margin;
            const effectiveHeight = canvasHeight - 2 * margin;
            const gridCols = Math.floor(effectiveWidth / gridSize);
            const gridRows = Math.floor(effectiveHeight / gridSize);
            
            // Define spawn points (using grid coordinates, within effective area)
            const spawnPoints = [
                {gridX: 5, gridY: 5},
                {gridX: gridCols - 5, gridY: 5},
                {gridX: 5, gridY: gridRows - 5},
                {gridX: gridCols - 5, gridY: gridRows - 5}
            ];
            const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            
            // Convert to pixel coordinates (add margin offset)
            const pixelX = margin + spawnPoint.gridX * gridSize;
            const pixelY = margin + spawnPoint.gridY * gridSize;
            
                                     snake = [
                { x: pixelX, y: pixelY },
                { x: pixelX - gridSize, y: pixelY },
                { x: pixelX - gridSize * 2, y: pixelY },
                { x: pixelX - gridSize * 3, y: pixelY }
            ];
            
            // Initial direction
            direction = 'right';
            nextDirection = 'right';
            
                         // Reset score and level
             score = 0;
             level = 1;
             gameSpeed = 100; // Slightly increase speed to adapt to larger game area
            
            // æ›´æ–°UI
            updateScore();
            
            // ä¿å­˜ç©å®¶ä¿¡æ¯åˆ°Firebase
            savePlayerInfo();
            
            // ç›‘å¬å…¶ä»–ç©å®¶å’Œé£Ÿç‰©
            listenForGameUpdates();
            
            // åˆå§‹åŒ–æ’è¡Œæ¦œæ˜¾ç¤º
            database.ref(`rooms/${gameRoom}/leaderboard`).once('value', (snapshot) => {
                const leaderboard = snapshot.val() || [];
                updateLeaderboardDisplay(leaderboard);
            });
            
            // åˆå§‹ç”Ÿæˆé£Ÿç‰©ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            database.ref(`rooms/${gameRoom}/foods`).once('value', (snapshot) => {
                if (!snapshot.exists() || !snapshot.val() || snapshot.val().length === 0) {
                    generateInitialFoods();
                }
            });
            
            // ç»˜åˆ¶åˆå§‹çŠ¶æ€
            draw();
        }
        
        // ä¿å­˜ç©å®¶ä¿¡æ¯åˆ°Firebase
        function savePlayerInfo() {
            const playerRef = database.ref(`rooms/${gameRoom}/players/${playerId}`);
            
            // è®¾ç½®ç©å®¶åˆå§‹ä¿¡æ¯
            playerRef.set({
                name: playerName,
                wallet: playerWallet,
                snake: snake,
                direction: direction,
                score: score,
                alive: true,
                color: playerColor || memeColors[Math.floor(Math.random() * memeColors.length)],
                room: gameRoom,
                lastActive: Date.now()
            });
            
            // å½“é¡µé¢å…³é—­æ—¶ç§»é™¤ç©å®¶
            window.addEventListener('beforeunload', () => {
                playerRef.remove();
            });
            
            // å®šæœŸæ›´æ–°æœ€åæ´»åŠ¨æ—¶é—´
            setInterval(() => {
                if (isGameRunning && !isPaused) {
                    playerRef.update({
                        lastActive: Date.now()
                    });
                }
            }, 5000);
        }
        
        // ç›‘å¬æ¸¸æˆæ›´æ–°
        function listenForGameUpdates() {
            // ç›‘å¬æ¸¸æˆçŠ¶æ€
            database.ref('gameState').on('value', (snapshot) => {
                if (snapshot.exists()) {
                    const gameState = snapshot.val();
                    handleGameStateChange(gameState);
                }
            });
            
            // ç›‘å¬å…¶ä»–ç©å®¶
            database.ref(`rooms/${gameRoom}/players`).on('value', (snapshot) => {
                const players = snapshot.val() || {};
                otherPlayers = {};
                
                // æ›´æ–°ç©å®¶åˆ—è¡¨
                playersListElement.innerHTML = '';
                playerCountElement.textContent = Object.keys(players).length;
                
                let activeCount = 0;
                Object.keys(players).forEach(id => {
                    if (id !== playerId && players[id].alive) {
                        otherPlayers[id] = players[id];
                        activeCount++;
                    }
                    
                    // æ·»åŠ åˆ°ç©å®¶åˆ—è¡¨
                    const li = document.createElement('li');
                    li.className = id === playerId ? 'text-memeGreen font-bold' : '';
                    li.innerHTML = `<span style="color: ${players[id].color}">â—</span> ${players[id].name} (${players[id].score})`;
                    playersListElement.appendChild(li);
                });
                
                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                totalPlayersElement.textContent = Object.keys(players).length;
                activePlayersElement.textContent = activeCount + (isGameRunning ? 1 : 0);
            });
            
            // ç›‘å¬é£Ÿç‰©
            database.ref(`rooms/${gameRoom}/foods`).on('value', (snapshot) => {
                if (snapshot.exists()) {
                    foods = snapshot.val() || [];
                } else {
                    foods = [];
                }
            });
            
            // ç›‘å¬ç‰¹æ®Šé£Ÿç‰©
            database.ref(`rooms/${gameRoom}/specialFood`).on('value', (snapshot) => {
                if (snapshot.exists()) {
                    specialFood = snapshot.val();
                } else {
                    specialFood = null;
                }
            });
            
            // ç›‘å¬å°¸ä½“é£Ÿç‰©
            database.ref(`rooms/${gameRoom}/corpseFoods`).on('value', (snapshot) => {
                if (snapshot.exists()) {
                    corpseFoods = snapshot.val() || [];
                } else {
                    corpseFoods = [];
                }
            });
            
            // ç›‘å¬æˆ¿é—´æ’è¡Œæ¦œ
            database.ref(`rooms/${gameRoom}/leaderboard`).on('value', (snapshot) => {
                const leaderboard = snapshot.val() || [];
                let maxScore = 0;
                
                if (leaderboard.length > 0) {
                    maxScore = leaderboard[0].score || 0;
                }
                
                roomHighScoreElement.textContent = maxScore;
                
                // æ›´æ–°æ’è¡Œæ¦œæ˜¾ç¤º
                updateLeaderboardDisplay(leaderboard);
            });
        }
        
        // å¤„ç†æ¸¸æˆçŠ¶æ€å˜åŒ–
        function handleGameStateChange(gameState) {
            if (!gameState.isRunning && isGameRunning) {
                // æ¸¸æˆè¢«æš‚åœ
                pauseGame();
                showGamePausedMessage();
            } else if (gameState.isRunning && !isGameRunning) {
                // æ¸¸æˆæ¢å¤
                resumeGame();
                hideGamePausedMessage();
            }
            
            // æ›´æ–°å€’è®¡æ—¶æ˜¾ç¤º
            updateCountdown(gameState.nextReset);
        }
        
        // æ˜¾ç¤ºæ¸¸æˆæš‚åœæ¶ˆæ¯
        function showGamePausedMessage() {
            const message = document.createElement('div');
            message.id = 'gamePausedMessage';
            message.className = 'absolute inset-0 bg-gray-900/90 flex items-center justify-center z-20';
            message.innerHTML = `
                <div class="text-center">
                    <h2 class="text-3xl font-bold text-yellow-400 mb-4">Game Paused</h2>
                    <p class="text-xl text-white">Waiting for admin to resume game...</p>
                </div>
            `;
            canvas.parentElement.appendChild(message);
        }
        
        // éšè—æ¸¸æˆæš‚åœæ¶ˆæ¯
        function hideGamePausedMessage() {
            const message = document.getElementById('gamePausedMessage');
            if (message) {
                message.remove();
            }
        }
        
        // æ›´æ–°å€’è®¡æ—¶æ˜¾ç¤º
        function updateCountdown(nextReset) {
            if (!nextReset) return;
            
            const timeLeft = Math.max(0, nextReset - Date.now());
            const minutes = Math.floor(timeLeft / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);
            
            // æ›´æ–°å€’è®¡æ—¶æ˜¾ç¤º
            const countdownEl = document.getElementById('countdown');
            if (countdownEl) {
                countdownEl.textContent = `Next Reset: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // å½“æ—¶é—´å°‘äº5åˆ†é’Ÿæ—¶æ˜¾ç¤ºè­¦å‘Š
                if (timeLeft < 300000) {
                    countdownEl.className = 'text-red-400 font-bold';
                } else if (timeLeft < 600000) {
                    countdownEl.className = 'text-yellow-400 font-bold';
                } else {
                    countdownEl.className = 'text-white';
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡ç½®æ’è¡Œæ¦œï¼ˆå½“å€’è®¡æ—¶ç»“æŸæ—¶ï¼‰
            if (timeLeft <= 0) {
                // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ’è¡Œæ¦œé‡ç½®é€»è¾‘
                // ç›®å‰æ’è¡Œæ¦œä¼šæŒç»­ä¿å­˜ï¼Œé™¤éç®¡ç†å‘˜æ‰‹åŠ¨é‡ç½®
            }
        }
        
        // æš‚åœæ¸¸æˆ
        function pauseGame() {
            isGameRunning = false;
            if (gameLoop) {
                clearInterval(gameLoop);
                gameLoop = null;
            }
        }
        
        // æ¢å¤æ¸¸æˆ
        function resumeGame() {
            if (!isGameRunning) {
                isGameRunning = true;
                startGameLoop();
            }
        }
        
        // å¯åŠ¨æ¸¸æˆå¾ªç¯
        function startGameLoop() {
            if (gameLoop) {
                clearInterval(gameLoop);
            }
            gameLoop = setInterval(gameUpdate, gameSpeed);
        }
        
        // æ›´æ–°æ’è¡Œæ¦œæ˜¾ç¤º
        function updateLeaderboardDisplay(leaderboard) {
            leaderboardElement.innerHTML = '';
            
            leaderboard.forEach((entry, index) => {
                const li = document.createElement('li');
                li.className = index === 0 ? 'text-memeYellow font-bold' : 
                              index === 1 ? 'text-gray-300' : 
                              index === 2 ? 'text-amber-700' : '';
                
                // æ ¼å¼åŒ–æ—¶é—´ (UTC)
                const date = new Date(entry.timestamp);
                const timeStr = `${date.getUTCMonth() + 1}/${date.getUTCDate()} ${date.getUTCHours()}:${date.getUTCMinutes().toString().padStart(2, '0')} UTC`;
                
                li.innerHTML = `${index + 1}. ${entry.playerName} - ${entry.score} pts <span class="text-xs text-gray-500">(${timeStr})</span>`;
                leaderboardElement.appendChild(li);
            });
        }
        
        // æ›´æ–°å½“å‰ç©å®¶æ’è¡Œæ¦œï¼ˆç”¨äºå®æ—¶æ˜¾ç¤ºï¼‰
        function updateLeaderboard(players) {
            // è¿™ä¸ªå‡½æ•°ç°åœ¨ä¸»è¦ç”¨äºå®æ—¶æ˜¾ç¤ºå½“å‰åœ¨çº¿ç©å®¶çš„åˆ†æ•°
            // ä¸å†ç”¨äºæŒä¹…åŒ–æ’è¡Œæ¦œ
        }
        

        
        // ç”Ÿæˆåˆå§‹é£Ÿç‰©ï¼ˆç”Ÿæˆå¤šä¸ªé£Ÿç‰©ï¼‰
        function generateInitialFoods() {
            const gridSize = 15; // å›ºå®šç½‘æ ¼å¤§å°
            const foodsToGenerate = Math.min(MAX_FOODS, 3); // åˆå§‹ç”Ÿæˆ3ä¸ªé£Ÿç‰©
            
            database.ref(`rooms/${gameRoom}/players`).once('value', (snapshot) => {
                const players = snapshot.val() || {};
                const newFoods = [];
                
                for (let i = 0; i < foodsToGenerate; i++) {
                    const newFood = generateSingleFood(players, newFoods);
                    if (newFood) {
                        newFoods.push(newFood);
                    }
                }
                
                // ä¿å­˜æ‰€æœ‰é£Ÿç‰©åˆ°Firebase
                database.ref(`rooms/${gameRoom}/foods`).set(newFoods);
            });
        }
        
        // ç”Ÿæˆå•ä¸ªé£Ÿç‰©
        function generateSingleFood(players, existingFoods = []) {
            // ä½¿ç”¨å›ºå®šçš„ç½‘æ ¼å°ºå¯¸ï¼Œç¡®ä¿æ‰€æœ‰ç©å®¶çœ‹åˆ°ç›¸åŒçš„åœ°å›¾
            const gridSize = 15; // å›ºå®šç½‘æ ¼å¤§å°
            let attempts = 0;
            const maxAttempts = 100;
            
            while (attempts < maxAttempts) {
                attempts++;
                // ä½¿ç”¨å›ºå®šçš„ç”»å¸ƒå°ºå¯¸è®¡ç®—æœ‰æ•ˆæ¸¸æˆåŒºåŸŸ
                const canvasWidth = 1200;
                const canvasHeight = 960;
                const margin = Math.floor(canvasWidth * 0.05); // 60pxè¾¹è·
                const effectiveWidth = canvasWidth - 2 * margin;
                const effectiveHeight = canvasHeight - 2 * margin;
                const gridCols = Math.floor(effectiveWidth / gridSize);
                const gridRows = Math.floor(effectiveHeight / gridSize);
                
                // ç”Ÿæˆéšæœºç½‘æ ¼åæ ‡ï¼ˆåœ¨æœ‰æ•ˆåŒºåŸŸå†…ï¼‰
                const gridX = Math.floor(Math.random() * gridCols);
                const gridY = Math.floor(Math.random() * gridRows);
                
                // è½¬æ¢ä¸ºåƒç´ åæ ‡ï¼ˆåŠ ä¸Šè¾¹è·åç§»ï¼‰
                const pixelX = margin + gridX * gridSize;
                const pixelY = margin + gridY * gridSize;
                
                const newFood = {
                    x: pixelX,
                    y: pixelY,
                    color: memeColors[Math.floor(Math.random() * memeColors.length)],
                    meme: memeFaces[Math.floor(Math.random() * memeFaces.length)],
                    timestamp: Date.now(),
                    id: 'food_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9)
                };
                
                let validPosition = true;
                
                // æ£€æŸ¥æ˜¯å¦ä¸å½“å‰ç©å®¶è›‡èº«é‡å 
                for (let segment of snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
                
                if (!validPosition) continue;
                
                // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–ç©å®¶è›‡èº«é‡å 
                Object.values(players).forEach(player => {
                    if (player.snake && player.alive) {
                        for (let segment of player.snake) {
                            if (segment.x === newFood.x && segment.y === newFood.y) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                    if (!validPosition) return;
                });
                
                // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰é£Ÿç‰©é‡å 
                existingFoods.forEach(food => {
                    if (food.x === newFood.x && food.y === newFood.y) {
                        validPosition = false;
                    }
                });
                
                // æ£€æŸ¥æ˜¯å¦ä¸å°¸ä½“é£Ÿç‰©é‡å 
                if (corpseFoods && corpseFoods.length > 0) {
                    corpseFoods.forEach(corpseFood => {
                        if (corpseFood.x === newFood.x && corpseFood.y === newFood.y) {
                            validPosition = false;
                        }
                    });
                }
                
                if (validPosition) {
                    return newFood;
                }
            }
            
            // å¦‚æœæ‰¾ä¸åˆ°æœ‰æ•ˆä½ç½®ï¼Œè¿”å›null
            return null;
        }
        
        // ç”Ÿæˆæ™®é€šé£Ÿç‰©ï¼ˆå½“é£Ÿç‰©è¢«åƒæ‰æ—¶è°ƒç”¨ï¼‰
        function generateFood() {
            const gridSize = 15; // å›ºå®šç½‘æ ¼å¤§å°
            
            // ç¡®ä¿é£Ÿç‰©ä¸ä¼šå‡ºç°åœ¨ä»»ä½•è›‡èº«ä¸Š
            database.ref(`rooms/${gameRoom}/players`).once('value', (snapshot) => {
                const players = snapshot.val() || {};
                
                // è·å–å½“å‰é£Ÿç‰©åˆ—è¡¨
                database.ref(`rooms/${gameRoom}/foods`).once('value', (foodsSnapshot) => {
                    const currentFoods = foodsSnapshot.val() || [];
                    
                    // å¦‚æœå½“å‰é£Ÿç‰©æ•°é‡å°‘äºæœ€å¤§æ•°é‡ï¼Œç”Ÿæˆæ–°é£Ÿç‰©
                    if (currentFoods.length < MAX_FOODS) {
                        const newFood = generateSingleFood(players, currentFoods);
                        if (newFood) {
                            currentFoods.push(newFood);
                            database.ref(`rooms/${gameRoom}/foods`).set(currentFoods);
                        }
                    }
                });
            });
        }
        
                         // ç”Ÿæˆç‰¹æ®Šé£Ÿç‰©
        function generateSpecialFood() {
            // ä½¿ç”¨å›ºå®šçš„ç½‘æ ¼å°ºå¯¸ï¼Œç¡®ä¿æ‰€æœ‰ç©å®¶çœ‹åˆ°ç›¸åŒçš„åœ°å›¾
            const gridSize = 15; // å›ºå®šç½‘æ ¼å¤§å°
            let newFood;
            
            // ç¡®ä¿ç‰¹æ®Šé£Ÿç‰©ä¸ä¼šå‡ºç°åœ¨ä»»ä½•è›‡èº«ä¸Šæˆ–æ™®é€šé£Ÿç‰©ä½ç½®
            database.ref(`rooms/${gameRoom}/players`).once('value', (playersSnapshot) => {
                database.ref(`rooms/${gameRoom}/foods`).once('value', (foodsSnapshot) => {
                    const players = playersSnapshot.val() || {};
                    const currentFoods = foodsSnapshot.val() || [];
                    let validPosition = false;
                    
                    while (!validPosition) {
                        // ä½¿ç”¨å›ºå®šçš„ç”»å¸ƒå°ºå¯¸è®¡ç®—æœ‰æ•ˆæ¸¸æˆåŒºåŸŸ
                        const canvasWidth = 1200;
                        const canvasHeight = 960;
                        const margin = Math.floor(canvasWidth * 0.05); // 60pxè¾¹è·
                        const effectiveWidth = canvasWidth - 2 * margin;
                        const effectiveHeight = canvasHeight - 2 * margin;
                        const gridCols = Math.floor(effectiveWidth / gridSize);
                        const gridRows = Math.floor(effectiveHeight / gridSize);
                        
                        // ç”Ÿæˆéšæœºç½‘æ ¼åæ ‡ï¼ˆåœ¨æœ‰æ•ˆåŒºåŸŸå†…ï¼‰
                        const gridX = Math.floor(Math.random() * gridCols);
                        const gridY = Math.floor(Math.random() * gridRows);
                        
                        // è½¬æ¢ä¸ºåƒç´ åæ ‡ï¼ˆåŠ ä¸Šè¾¹è·åç§»ï¼‰
                        const pixelX = margin + gridX * gridSize;
                        const pixelY = margin + gridY * gridSize;
                        
                        newFood = {
                            x: pixelX,
                            y: pixelY,
                            color: '#FFFFFF',
                            meme: 'âœ¨',
                            timestamp: Date.now(),
                            timer: 50 // å­˜åœ¨50ä¸ªæ¸¸æˆå¸§
                        };
                        
                        validPosition = true;
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸æ™®é€šé£Ÿç‰©é‡å 
                        currentFoods.forEach(food => {
                            if (food.x === newFood.x && food.y === newFood.y) {
                                validPosition = false;
                            }
                        });
                        
                        if (!validPosition) continue;
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸å°¸ä½“é£Ÿç‰©é‡å 
                        if (corpseFoods && corpseFoods.length > 0) {
                            corpseFoods.forEach(corpseFood => {
                                if (corpseFood.x === newFood.x && corpseFood.y === newFood.y) {
                                    validPosition = false;
                                }
                            });
                        }
                        
                        if (!validPosition) continue;
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸å½“å‰ç©å®¶è›‡èº«é‡å 
                        for (let segment of snake) {
                            if (segment.x === newFood.x && segment.y === newFood.y) {
                                validPosition = false;
                                break;
                            }
                        }
                        
                        if (!validPosition) continue;
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–ç©å®¶è›‡èº«é‡å 
                        Object.values(players).forEach(player => {
                            if (player.snake && player.alive) {
                                for (let segment of player.snake) {
                                    if (segment.x === newFood.x && segment.y === newFood.y) {
                                        validPosition = false;
                                        break;
                                    }
                                }
                            }
                            if (!validPosition) return;
                        });
                    }
                    
                    // ä¿å­˜ç‰¹æ®Šé£Ÿç‰©åˆ°Firebase
                    database.ref(`rooms/${gameRoom}/specialFood`).set(newFood);
                    
                    // 5ç§’åç§»é™¤ç‰¹æ®Šé£Ÿç‰©
                    setTimeout(() => {
                        database.ref(`rooms/${gameRoom}/specialFood`).once('value', (snapshot) => {
                            if (snapshot.exists() && snapshot.val().timestamp === newFood.timestamp) {
                                database.ref(`rooms/${gameRoom}/specialFood`).remove();
                            }
                        });
                    }, 5000);
                });
            });
        }
        
        // æ›´æ–°åˆ†æ•°
        function updateScore() {
            scoreElement.textContent = score;
            finalScoreElement.textContent = score;
            
            // æ›´æ–°Firebaseä¸­çš„åˆ†æ•°
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).update({
                    score: score
                });
                
                // åŒæ—¶æ›´æ–°ç”¨æˆ·é’±åŒ…ä¸‹çš„æ€»ç§¯åˆ†
                database.ref(`users/${playerWallet}`).update({
                    score: score,
                    lastUpdated: Date.now()
                });
            }
        }
        
                         // æ£€æŸ¥ç¢°æ’
        function checkCollision() {
            const head = snake[0];
            const gridSize = 15; // å›ºå®šç½‘æ ¼å¤§å°
            
            // æ£€æŸ¥å¢™å£ç¢°æ’ï¼ˆè€ƒè™‘è¾¹è·ï¼‰
            if (head.x < gameMargin || head.x >= canvas.width - gameMargin || 
                head.y < gameMargin || head.y >= canvas.height - gameMargin) {
                return true;
            }
            
            // æ£€æŸ¥è‡ªèº«ç¢°æ’
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            
            // æ£€æŸ¥ä¸å…¶ä»–ç©å®¶ç¢°æ’ï¼ˆåŒ…æ‹¬æ­»äº¡ç©å®¶çš„è›‡èº«ä½“ï¼‰
            Object.values(otherPlayers).forEach(player => {
                if (player.snake) {
                    for (let segment of player.snake) {
                        if (head.x === segment.x && head.y === segment.y) {
                            return true;
                        }
                    }
                }
            });
            
            return false;
        }
        
        // æ£€æŸ¥é£Ÿç‰©ç¢°æ’
        function checkFoodCollision() {
            const head = snake[0];
            const gridSize = 15; // å›ºå®šç½‘æ ¼å¤§å°
            let ateFood = false;
            
            // æ£€æŸ¥æ™®é€šé£Ÿç‰©ç¢°æ’
            if (foods && foods.length > 0) {
                for (let i = 0; i < foods.length; i++) {
                    const food = foods[i];
                    
                    // è°ƒè¯•ä¿¡æ¯ï¼šæ˜¾ç¤ºè›‡å¤´å’Œé£Ÿç‰©çš„åæ ‡
                    console.log('ç¢°æ’æ£€æµ‹:', {
                        head: {x: head.x, y: head.y},
                        food: {x: food.x, y: food.y},
                        gridSize: gridSize,
                        distance: Math.sqrt(Math.pow(head.x - food.x, 2) + Math.pow(head.y - food.y, 2))
                    });
                    
                    // ä½¿ç”¨æ›´å®½æ¾çš„ç¢°æ’æ£€æµ‹
                    if (Math.abs(head.x - food.x) < gridSize/2 && Math.abs(head.y - food.y) < gridSize/2) {
                        console.log('åƒåˆ°æ™®é€šé£Ÿç‰©!', {head, food}); // è°ƒè¯•ä¿¡æ¯
                        
                        // å¢åŠ åˆ†æ•°
                        score += 10;
                        
                        // æ¯100åˆ†å‡çº§
                        if (score % 100 === 0) {
                            level++;
                            // åŠ å¿«æ¸¸æˆé€Ÿåº¦ï¼Œæœ€ä½50ms
                            gameSpeed = Math.max(50, gameSpeed - 10);
                            // é‡æ–°è®¾ç½®æ¸¸æˆå¾ªç¯é€Ÿåº¦
                            if (isGameRunning && !isPaused) {
                                clearInterval(gameLoop);
                                gameLoop = setInterval(gameUpdate, gameSpeed);
                            }
                        }
                        
                        updateScore();
                        
                        // ç§»é™¤è¢«åƒæ‰çš„é£Ÿç‰©
                        const updatedFoods = foods.filter((_, index) => index !== i);
                        database.ref(`rooms/${gameRoom}/foods`).set(updatedFoods);
                        
                        // æ’­æ”¾åƒé£Ÿç‰©éŸ³æ•ˆ
                        playEatSound();
                        
                        // ç”Ÿæˆæ–°é£Ÿç‰©
                        generateFood();
                        
                        // æœ‰10%çš„å‡ ç‡ç”Ÿæˆç‰¹æ®Šé£Ÿç‰©
                        if (Math.random() < 0.1) {
                            generateSpecialFood();
                        }
                        
                        ateFood = true;
                        break; // ä¸€æ¬¡åªèƒ½åƒä¸€ä¸ªé£Ÿç‰©
                    }
                }
            }
            
            // æ£€æŸ¥å°¸ä½“é£Ÿç‰©ç¢°æ’
            if (corpseFoods && corpseFoods.length > 0) {
                for (let i = 0; i < corpseFoods.length; i++) {
                    const corpseFood = corpseFoods[i];
                    
                    // ä½¿ç”¨æ›´å®½æ¾çš„ç¢°æ’æ£€æµ‹
                    if (Math.abs(head.x - corpseFood.x) < gridSize/2 && Math.abs(head.y - corpseFood.y) < gridSize/2) {
                        console.log('åƒåˆ°å°¸ä½“é£Ÿç‰©!', {head, corpseFood}); // è°ƒè¯•ä¿¡æ¯
                        
                        // æ’­æ”¾åƒé£Ÿç‰©éŸ³æ•ˆ
                        playEatSound();
                        
                        // å°¸ä½“é£Ÿç‰©åªåŠ åˆ†æ•°ï¼Œä¸å¢åŠ è›‡é•¿åº¦
                        score += 5;
                        updateScore();
                        
                        // ç§»é™¤è¢«åƒæ‰çš„å°¸ä½“é£Ÿç‰©
                        const updatedCorpseFoods = corpseFoods.filter((_, index) => index !== i);
                        database.ref(`rooms/${gameRoom}/corpseFoods`).set(updatedCorpseFoods);
                        
                        // æ³¨æ„ï¼šä¸åƒå°¸ä½“é£Ÿç‰©ï¼Œæ‰€ä»¥ä¸è®¾ç½®ateFood = true
                        break; // ä¸€æ¬¡åªèƒ½åƒä¸€ä¸ªé£Ÿç‰©
                    }
                }
            }
            
            // ç‰¹æ®Šé£Ÿç‰© - ä½¿ç”¨æ›´å®½æ¾çš„ç¢°æ’æ£€æµ‹
            if (specialFood && Math.abs(head.x - specialFood.x) < gridSize/2 && Math.abs(head.y - specialFood.y) < gridSize/2) {
                console.log('åƒåˆ°ç‰¹æ®Šé£Ÿç‰©!', {head, specialFood}); // è°ƒè¯•ä¿¡æ¯
                
                // æ’­æ”¾åƒé£Ÿç‰©éŸ³æ•ˆ
                playEatSound();
                
                // ç‰¹æ®Šé£Ÿç‰©ç»™æ›´å¤šåˆ†æ•°
                score += 50;
                updateScore();
                database.ref(`rooms/${gameRoom}/specialFood`).remove();
                ateFood = true;
            }
            
            return ateFood;
        }
        
        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function gameUpdate() {
            if (isPaused || !isGameRunning) return;
            
                                     // æ›´æ–°æ–¹å‘
            direction = nextDirection;
            
            const gridSize = 15; // å›ºå®šç½‘æ ¼å¤§å°
            const head = { x: snake[0].x, y: snake[0].y };
            
            // æ ¹æ®æ–¹å‘ç§»åŠ¨è›‡å¤´
            switch (direction) {
                case 'up':
                    head.y -= gridSize;
                    break;
                case 'down':
                    head.y += gridSize;
                    break;
                case 'left':
                    head.x -= gridSize;
                    break;
                case 'right':
                    head.x += gridSize;
                    break;
            }
            
            // å°†æ–°å¤´éƒ¨æ·»åŠ åˆ°è›‡
            snake.unshift(head);
            
            // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
            const ateFood = checkFoodCollision();
            
            // å¦‚æœæ²¡åƒåˆ°é£Ÿç‰©ï¼Œç§»é™¤å°¾éƒ¨
            if (!ateFood) {
                snake.pop();
            }
            
            // æ£€æŸ¥ç¢°æ’
            if (checkCollision()) {
                gameOver();
                return;
            }
            
            // æ›´æ–°Firebaseä¸­çš„è›‡çŠ¶æ€
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).update({
                    snake: snake,
                    direction: direction
                });
            }
            
            // ç»˜åˆ¶æ¸¸æˆ
            draw();
        }
        
                         // ç»˜åˆ¶æ¸¸æˆ
        function draw() {
            const gridSize = 15; // å›ºå®šç½‘æ ¼å¤§å°
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = '#121212';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶è¾¹è·åŒºåŸŸï¼ˆåŒ…è¾¹ï¼‰
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, gameMargin); // ä¸Šè¾¹è·
            ctx.fillRect(0, canvas.height - gameMargin, canvas.width, gameMargin); // ä¸‹è¾¹è·
            ctx.fillRect(0, 0, gameMargin, canvas.height); // å·¦è¾¹è·
            ctx.fillRect(canvas.width - gameMargin, 0, gameMargin, canvas.height); // å³è¾¹è·
            
            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯ï¼ˆä»…åœ¨æœ‰æ•ˆæ¸¸æˆåŒºåŸŸå†…ï¼‰
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 1;
            
            // åªåœ¨æœ‰æ•ˆæ¸¸æˆåŒºåŸŸå†…ç»˜åˆ¶ç½‘æ ¼
            for (let x = gameMargin; x < canvas.width - gameMargin; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, gameMargin);
                ctx.lineTo(x, canvas.height - gameMargin);
                ctx.stroke();
            }
            
            for (let y = gameMargin; y < canvas.height - gameMargin; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(gameMargin, y);
                ctx.lineTo(canvas.width - gameMargin, y);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶å…¶ä»–ç©å®¶çš„è›‡
            Object.values(otherPlayers).forEach(player => {
                if (player.snake) {
                    player.snake.forEach((segment, index) => {
                        // è›‡å¤´ï¼ˆç®€åŒ–æ˜¾ç¤ºï¼‰
                        if (index === 0) {
                            
                            // ç»˜åˆ¶è›‡å¤´å›¾ç‰‡ï¼ˆæ­£æ–¹å½¢ï¼‰
                            if (snakeHeadImage && snakeHeadImage.complete) {
                                ctx.save();
                                ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                
                                // æ ¹æ®æ–¹å‘æ—‹è½¬å›¾ç‰‡
                                let rotation = 0;
                                switch (player.direction || 'right') {
                                    case 'up': rotation = -Math.PI / 2; break;
                                    case 'down': rotation = Math.PI / 2; break;
                                    case 'left': rotation = Math.PI; break;
                                    case 'right': rotation = 0; break;
                                }
                                ctx.rotate(rotation);
                                
                                // æ·»åŠ æ°´å¹³ç¿»è½¬æ¥ä¿®å¤ä¸Šä¸‹é¢ å€’é—®é¢˜
                                ctx.scale(1, -1);
                                ctx.drawImage(snakeHeadImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                ctx.restore();
                            } else {
                                // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨é»˜è®¤è¡¨æƒ…
                                ctx.fillStyle = 'white';
                                ctx.font = `${gridSize * 0.7}px "Comic Sans MS", cursive`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText('ğŸ˜œ', segment.x + gridSize / 2, segment.y + gridSize / 2);
                            }
                            
                            // ç©å®¶åç§°æ ‡ç­¾
                            ctx.fillStyle = player.color;
                            ctx.font = `${gridSize * 0.4}px "Comic Sans MS", cursive`;
                            ctx.fillText(player.name, segment.x + gridSize / 2, segment.y - 10);
                        } else if (index === player.snake.length - 1) {
                            // è›‡å°¾ï¼ˆæœ€åä¸€ä¸ªä½ç½®ï¼‰
                            if (snakeTailImage && snakeTailImage.complete) {
                                ctx.save();
                                ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                
                                // è®¡ç®—è›‡å°¾çš„æ–¹å‘ï¼ˆåŸºäºå€’æ•°ç¬¬äºŒä¸ªä½ç½®ï¼‰
                                let tailDirection = 'right';
                                if (player.snake.length > 1) {
                                    const secondLast = player.snake[player.snake.length - 2];
                                    const last = player.snake[player.snake.length - 1];
                                    
                                    if (last.x > secondLast.x) tailDirection = 'right';
                                    else if (last.x < secondLast.x) tailDirection = 'left';
                                    else if (last.y > secondLast.y) tailDirection = 'down';
                                    else if (last.y < secondLast.y) tailDirection = 'up';
                                }
                                
                                                        // æ ¹æ®æ–¹å‘æ—‹è½¬å›¾ç‰‡ï¼ˆå°¾å·´æ ¹éƒ¨æ­£ç¡®æ–¹å‘ï¼‰
                        let rotation = 0;
                        switch (tailDirection) {
                            case 'up': rotation = -Math.PI / 2; break;   // å‘ä¸Šï¼š-90åº¦
                            case 'down': rotation = Math.PI / 2; break;  // å‘ä¸‹ï¼š90åº¦
                            case 'left': rotation = Math.PI; break;      // å‘å·¦ï¼š180åº¦
                            case 'right': rotation = 0; break;           // å‘å³ï¼š0åº¦
                        }
                                ctx.rotate(rotation);
                                
                                // åˆ›å»ºåœ†å½¢è£å‰ªåŒºåŸŸ
                                ctx.beginPath();
                                ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                                ctx.clip();
                                
                                ctx.drawImage(snakeTailImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                ctx.restore();
                            } else {
                                // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨é»˜è®¤åœ†å½¢
                                ctx.fillStyle = player.color;
                                ctx.beginPath();
                                ctx.arc(segment.x + gridSize/2, segment.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        } else {
                                                        // è›‡èº«
                            if (snakeBodyImage && snakeBodyImage.complete) {
                                // è®¡ç®—è›‡èº«çš„æ–¹å‘ï¼ˆåŸºäºå‰åä¸¤ä¸ªä½ç½®ï¼‰
                                let bodyDirection = 'right';
                                let isCorner = false;
                                
                                if (index > 0 && index < player.snake.length - 1) {
                                    const prev = player.snake[index - 1];
                                    const next = player.snake[index + 1];
                                    
                                    // æ£€æŸ¥æ˜¯å¦æ˜¯æ‹å¼¯ç‚¹ï¼ˆå‰åä½ç½®å½¢æˆç›´è§’ï¼‰
                                    isCorner = (prev.x !== next.x) && (prev.y !== next.y);
                                    
                                    if (isCorner) {
                                        // æ‹å¼¯ç‚¹ï¼šæ ¹æ®å½“å‰æ®µä¸å‰ä¸€æ®µçš„ç›¸å¯¹ä½ç½®ç¡®å®šæ–¹å‘
                                        const current = player.snake[index];
                                        if (current.x > prev.x) bodyDirection = 'right';
                                        else if (current.x < prev.x) bodyDirection = 'left';
                                        else if (current.y > prev.y) bodyDirection = 'down';
                                        else if (current.y < prev.y) bodyDirection = 'up';
                                    } else {
                                        // ç›´çº¿æ®µï¼šä½¿ç”¨å‰åä½ç½®è®¡ç®—æ–¹å‘
                                        if (next.x > prev.x) bodyDirection = 'right';
                                        else if (next.x < prev.x) bodyDirection = 'left';
                                        else if (next.y > prev.y) bodyDirection = 'down';
                                        else if (next.y < prev.y) bodyDirection = 'up';
                                    }
                                } else if (index === 0) {
                                    // å¤´éƒ¨åçš„ç¬¬ä¸€èŠ‚ï¼Œä½¿ç”¨å¤´éƒ¨æ–¹å‘
                                    bodyDirection = player.direction || 'right';
                                } else {
                                    // å°¾éƒ¨å‰çš„æœ€åä¸€èŠ‚ï¼Œä½¿ç”¨å°¾éƒ¨æ–¹å‘
                                    const secondLast = player.snake[player.snake.length - 2];
                                    const last = player.snake[player.snake.length - 1];
                                    
                                    if (last.x > secondLast.x) bodyDirection = 'right';
                                    else if (last.x < secondLast.x) bodyDirection = 'left';
                                    else if (last.y > secondLast.y) bodyDirection = 'down';
                                    else if (last.y < secondLast.y) bodyDirection = 'up';
                                }
                                
                                if (isCorner) {
                                    // è½¬å¼¯ç‚¹ï¼šä½¿ç”¨ä¸“ç”¨è½¬å¼¯å›¾ç‰‡
                                    const prev = player.snake[index - 1];
                                    const next = player.snake[index + 1];
                                    const current = segment;
                                    
                                    // è®¡ç®—è½¬å¼¯æ–¹å‘
                                    const fromDirection = {
                                        x: current.x - prev.x,
                                        y: current.y - prev.y
                                    };
                                    const toDirection = {
                                        x: next.x - current.x,
                                        y: next.y - current.y
                                    };
                                    
                                    let turnImage = null;
                                    let rotation = 0;
                                    
                                    // åˆ¤æ–­è½¬å¼¯ç±»å‹å¹¶é€‰æ‹©å¯¹åº”å›¾ç‰‡
                                    if ((fromDirection.x === -15 && toDirection.y === 15) || (fromDirection.y === -15 && toDirection.x === 15)) {
                                        // å³ä¸‹è½¬å¼¯ï¼šä»å·¦åˆ°ä¸‹ æˆ– ä»ä¸Šåˆ°å³
                                        turnImage = snakeTurnEImage;
                                        rotation = 0;
                                    } else if ((fromDirection.x === 15 && toDirection.y === 15) || (fromDirection.y === -15 && toDirection.x === -15)) {
                                        // å·¦ä¸‹è½¬å¼¯ï¼šä»å³åˆ°ä¸‹ æˆ– ä»ä¸Šåˆ°å·¦
                                        turnImage = snakeTurnQImage;
                                        rotation = 0;
                                    } else if ((fromDirection.x === 15 && toDirection.y === -15) || (fromDirection.y === 15 && toDirection.x === -15)) {
                                        // å·¦ä¸Šè½¬å¼¯ï¼šä»å³åˆ°ä¸Š æˆ– ä»ä¸‹åˆ°å·¦
                                        turnImage = snakeTurnRImage;
                                        rotation = 0;
                                    } else if ((fromDirection.x === -15 && toDirection.y === -15) || (fromDirection.y === 15 && toDirection.x === 15)) {
                                        // å³ä¸Šè½¬å¼¯ï¼šä»å·¦åˆ°ä¸Š æˆ– ä»ä¸‹åˆ°å³
                                        turnImage = snakeTurnWImage;
                                        rotation = 0;
                                    }
                                    
                                    if (turnImage && turnImage.complete) {
                                        ctx.save();
                                        ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                        ctx.rotate(rotation);
                                        ctx.drawImage(turnImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                        ctx.restore();
                                    } else {
                                        // è½¬å¼¯å›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨æ™®é€šè›‡èº«å›¾ç‰‡
                                        ctx.save();
                                        ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                        ctx.drawImage(snakeBodyImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                        ctx.restore();
                                    }
                                } else {
                                    // ç›´çº¿æ®µï¼šä½¿ç”¨æ™®é€šè›‡èº«å›¾ç‰‡
                                    let rotation = 0;
                                    switch (bodyDirection) {
                                        case 'up': rotation = -Math.PI / 2; break;
                                        case 'down': rotation = Math.PI / 2; break;
                                        case 'left': rotation = Math.PI; break;
                                        case 'right': rotation = 0; break;
                                    }
                                    
                                    ctx.save();
                                    ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                    ctx.rotate(rotation);
                                    ctx.drawImage(snakeBodyImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                    ctx.restore();
                                }
                            } else {
                                // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨é»˜è®¤åœ†å½¢
                                ctx.fillStyle = player.color;
                                ctx.beginPath();
                                ctx.arc(segment.x + gridSize/2, segment.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    });
                }
            });
            
            // ç»˜åˆ¶è‡ªå·±çš„è›‡
            snake.forEach((segment, index) => {
                // è›‡å¤´ï¼ˆç®€åŒ–æ˜¾ç¤ºï¼‰
                if (index === 0) {
                    
                    // ç»˜åˆ¶è›‡å¤´å›¾ç‰‡ï¼ˆæ­£æ–¹å½¢ï¼‰
                    if (snakeHeadImage && snakeHeadImage.complete) {
                        ctx.save();
                        ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                        
                        // æ ¹æ®æ–¹å‘æ—‹è½¬å›¾ç‰‡
                        let rotation = 0;
                        switch (direction) {
                            case 'up': rotation = -Math.PI / 2; break;
                            case 'down': rotation = Math.PI / 2; break;
                            case 'left': rotation = Math.PI; break;
                            case 'right': rotation = 0; break;
                        }
                        ctx.rotate(rotation);
                        
                        // æ·»åŠ æ°´å¹³ç¿»è½¬æ¥ä¿®å¤ä¸Šä¸‹é¢ å€’é—®é¢˜
                        ctx.scale(1, -1);
                        ctx.drawImage(snakeHeadImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                        ctx.restore();
                    } else {
                        // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨é»˜è®¤è¡¨æƒ…
                        ctx.fillStyle = 'white';
                        ctx.font = `${gridSize * 0.7}px "Comic Sans MS", cursive`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ğŸ˜›', segment.x + gridSize / 2, segment.y + gridSize / 2);
                    }
                    
                    // è‡ªå·±çš„åç§°æ ‡ç­¾
                    ctx.fillStyle = '#FF3333';
                    ctx.font = `${gridSize * 0.4}px "Comic Sans MS", cursive`;
                    ctx.fillText(playerName, segment.x + gridSize / 2, segment.y - 10);
                                } else if (index === snake.length - 1) {
                    // è›‡å°¾ï¼ˆæœ€åä¸€ä¸ªä½ç½®ï¼‰
                    if (snakeTailImage && snakeTailImage.complete) {
                        ctx.save();
                        ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                        
                        // è®¡ç®—è›‡å°¾çš„æ–¹å‘ï¼ˆåŸºäºå€’æ•°ç¬¬äºŒä¸ªä½ç½®ï¼‰
                        let tailDirection = 'right';
                        if (snake.length > 1) {
                            const secondLast = snake[snake.length - 2];
                            const last = snake[snake.length - 1];
                            
                            if (last.x > secondLast.x) tailDirection = 'right';
                            else if (last.x < secondLast.x) tailDirection = 'left';
                            else if (last.y > secondLast.y) tailDirection = 'down';
                            else if (last.y < secondLast.y) tailDirection = 'up';
                        }
                        
                        // æ ¹æ®æ–¹å‘æ—‹è½¬å›¾ç‰‡ï¼ˆå°¾å·´æ ¹éƒ¨æ­£ç¡®æ–¹å‘ï¼‰
                        let rotation = 0;
                        switch (tailDirection) {
                            case 'up': rotation = -Math.PI / 2; break;   // å‘ä¸Šï¼š-90åº¦
                            case 'down': rotation = Math.PI / 2; break;  // å‘ä¸‹ï¼š90åº¦
                            case 'left': rotation = Math.PI; break;      // å‘å·¦ï¼š180åº¦
                            case 'right': rotation = 0; break;           // å‘å³ï¼š0åº¦
                        }
                        ctx.rotate(rotation);
                        
                        // åˆ›å»ºåœ†å½¢è£å‰ªåŒºåŸŸ
                        ctx.beginPath();
                        ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                        ctx.clip();
                        
                        ctx.drawImage(snakeTailImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                        ctx.restore();
                    } else {
                        // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨é»˜è®¤åœ†å½¢
                        const colorIndex = (index % memeColors.length);
                        ctx.fillStyle = memeColors[colorIndex];
                        ctx.beginPath();
                        ctx.arc(segment.x + gridSize/2, segment.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // è›‡èº«
                    if (snakeBodyImage && snakeBodyImage.complete) {
                        // è®¡ç®—è›‡èº«çš„æ–¹å‘ï¼ˆåŸºäºå‰åä¸¤ä¸ªä½ç½®ï¼‰
                        let bodyDirection = 'right';
                        let isCorner = false;
                        
                        if (index > 0 && index < snake.length - 1) {
                            const prev = snake[index - 1];
                            const next = snake[index + 1];
                            
                            // æ£€æŸ¥æ˜¯å¦æ˜¯æ‹å¼¯ç‚¹ï¼ˆå‰åä½ç½®å½¢æˆç›´è§’ï¼‰
                            isCorner = (prev.x !== next.x) && (prev.y !== next.y);
                            
                            if (isCorner) {
                                // æ‹å¼¯ç‚¹ï¼šæ ¹æ®å½“å‰æ®µä¸å‰ä¸€æ®µçš„ç›¸å¯¹ä½ç½®ç¡®å®šæ–¹å‘
                                const current = snake[index];
                                if (current.x > prev.x) bodyDirection = 'right';
                                else if (current.x < prev.x) bodyDirection = 'left';
                                else if (current.y > prev.y) bodyDirection = 'down';
                                else if (current.y < prev.y) bodyDirection = 'up';
                            } else {
                                // ç›´çº¿æ®µï¼šä½¿ç”¨å‰åä½ç½®è®¡ç®—æ–¹å‘
                                if (next.x > prev.x) bodyDirection = 'right';
                                else if (next.x < prev.x) bodyDirection = 'left';
                                else if (next.y > prev.y) bodyDirection = 'down';
                                else if (next.y < prev.y) bodyDirection = 'up';
                            }
                        } else if (index === 0) {
                            // å¤´éƒ¨åçš„ç¬¬ä¸€èŠ‚ï¼Œä½¿ç”¨å¤´éƒ¨æ–¹å‘
                            bodyDirection = direction;
                        } else {
                            // å°¾éƒ¨å‰çš„æœ€åä¸€èŠ‚ï¼Œä½¿ç”¨å°¾éƒ¨æ–¹å‘
                            const secondLast = snake[snake.length - 2];
                            const last = snake[snake.length - 1];
                            
                            if (last.x > secondLast.x) bodyDirection = 'right';
                            else if (last.x < secondLast.x) bodyDirection = 'left';
                            else if (last.y > secondLast.y) bodyDirection = 'down';
                            else if (last.y < secondLast.y) bodyDirection = 'up';
                        }
                        
                        if (isCorner) {
                            // è½¬å¼¯ç‚¹ï¼šä½¿ç”¨ä¸“ç”¨è½¬å¼¯å›¾ç‰‡
                            const prev = snake[index - 1];
                            const next = snake[index + 1];
                            const current = segment;
                            
                            // è®¡ç®—è½¬å¼¯æ–¹å‘
                            const fromDirection = {
                                x: current.x - prev.x,
                                y: current.y - prev.y
                            };
                            const toDirection = {
                                x: next.x - current.x,
                                y: next.y - current.y
                            };
                            
                            let turnImage = null;
                            let rotation = 0;
                            
                            // åˆ¤æ–­è½¬å¼¯ç±»å‹å¹¶é€‰æ‹©å¯¹åº”å›¾ç‰‡
                            if ((fromDirection.x === -15 && toDirection.y === 15) || (fromDirection.y === -15 && toDirection.x === 15)) {
                                // å³ä¸‹è½¬å¼¯ï¼šä»å·¦åˆ°ä¸‹ æˆ– ä»ä¸Šåˆ°å³
                                turnImage = snakeTurnEImage;
                                rotation = 0;
                            } else if ((fromDirection.x === 15 && toDirection.y === 15) || (fromDirection.y === -15 && toDirection.x === -15)) {
                                // å·¦ä¸‹è½¬å¼¯ï¼šä»å³åˆ°ä¸‹ æˆ– ä»ä¸Šåˆ°å·¦
                                turnImage = snakeTurnQImage;
                                rotation = 0;
                            } else if ((fromDirection.x === 15 && toDirection.y === -15) || (fromDirection.y === 15 && toDirection.x === -15)) {
                                // å·¦ä¸Šè½¬å¼¯ï¼šä»å³åˆ°ä¸Š æˆ– ä»ä¸‹åˆ°å·¦
                                turnImage = snakeTurnRImage;
                                rotation = 0;
                            } else if ((fromDirection.x === -15 && toDirection.y === -15) || (fromDirection.y === 15 && toDirection.x === 15)) {
                                // å³ä¸Šè½¬å¼¯ï¼šä»å·¦åˆ°ä¸Š æˆ– ä»ä¸‹åˆ°å³
                                turnImage = snakeTurnWImage;
                                rotation = 0;
                            }
                            
                            if (turnImage && turnImage.complete) {
                                ctx.save();
                                ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                ctx.rotate(rotation);
                                ctx.drawImage(turnImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                ctx.restore();
                            } else {
                                // è½¬å¼¯å›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨æ™®é€šè›‡èº«å›¾ç‰‡
                                ctx.save();
                                ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                ctx.drawImage(snakeBodyImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                ctx.restore();
                            }
                        } else {
                            // ç›´çº¿æ®µï¼šä½¿ç”¨æ™®é€šè›‡èº«å›¾ç‰‡
                            let rotation = 0;
                            switch (bodyDirection) {
                                case 'up': rotation = -Math.PI / 2; break;
                                case 'down': rotation = Math.PI / 2; break;
                                case 'left': rotation = Math.PI; break;
                                case 'right': rotation = 0; break;
                            }
                            
                            ctx.save();
                            ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                            ctx.rotate(rotation);
                            ctx.drawImage(snakeBodyImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                            ctx.restore();
                        }
                    } else {
                        // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨é»˜è®¤åœ†å½¢
                        const colorIndex = (index % memeColors.length);
                        ctx.fillStyle = memeColors[colorIndex];
                        ctx.beginPath();
                        ctx.arc(segment.x + gridSize/2, segment.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
            
                         // ç»˜åˆ¶æ™®é€šé£Ÿç‰©
             if (foods && foods.length > 0) {
                 foods.forEach(food => {
                     ctx.fillStyle = food.color;
                     ctx.shadowColor = food.color;
                     ctx.shadowBlur = 10;
                     ctx.beginPath();
                     ctx.arc(food.x + gridSize / 2, food.y + gridSize / 2, gridSize / 2, 0, Math.PI * 2);
                     ctx.fill();
                     ctx.shadowBlur = 0;
                     
                     // ç»˜åˆ¶é£Ÿç‰©å›¾ç‰‡
                     if (foodImage && foodImage.complete) {
                         ctx.save();
                         ctx.translate(food.x + gridSize / 2, food.y + gridSize / 2);
                         
                         // åˆ›å»ºåœ†å½¢è£å‰ªåŒºåŸŸ
                         ctx.beginPath();
                         ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                         ctx.clip();
                         
                         ctx.drawImage(foodImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                         ctx.restore();
                     } else {
                         // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨é»˜è®¤è¡¨æƒ…
                         ctx.fillStyle = 'black';
                         ctx.font = `${gridSize * 0.5}px "Comic Sans MS", cursive`;
                         ctx.textAlign = 'center';
                         ctx.textBaseline = 'middle';
                         ctx.fillText(food.meme, food.x + gridSize / 2, food.y + gridSize / 2);
                     }
                 });
             }
            
                         // ç»˜åˆ¶å°¸ä½“é£Ÿç‰©
             if (corpseFoods && corpseFoods.length > 0) {
                 corpseFoods.forEach(corpseFood => {
                     // ä¿å­˜å½“å‰ä¸Šä¸‹æ–‡
                     ctx.save();
                     
                     // è®¡ç®—åŠ¨ç”»æ•ˆæœ
                     const time = Date.now() / 1000;
                     const pulseScale = 1 + Math.sin(time * (corpseFood.pulse || 2)) * 0.1;
                     const wiggleOffset = Math.sin(time * 3) * (corpseFood.wiggle || 3);
                     const rotation = (corpseFood.rotation || 0) + Math.sin(time * 2) * 10;
                     
                     // è®¾ç½®å˜æ¢
                     ctx.translate(corpseFood.x + gridSize / 2 + wiggleOffset, corpseFood.y + gridSize / 2);
                     ctx.rotate(rotation * Math.PI / 180);
                     ctx.scale(pulseScale, pulseScale);
                     
                     // ç»˜åˆ¶å‘å…‰èƒŒæ™¯
                     const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, gridSize / 2);
                     gradient.addColorStop(0, corpseFood.color);
                     gradient.addColorStop(0.7, corpseFood.color + '80');
                     gradient.addColorStop(1, 'transparent');
                     
                     ctx.fillStyle = gradient;
                     ctx.shadowColor = corpseFood.color;
                     ctx.shadowBlur = 20;
                     ctx.beginPath();
                     ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                     ctx.fill();
                     
                     // ç»˜åˆ¶è¾¹æ¡†
                     ctx.strokeStyle = '#FFFFFF';
                     ctx.lineWidth = 2;
                     ctx.beginPath();
                     ctx.arc(0, 0, gridSize / 2 - 2, 0, Math.PI * 2);
                     ctx.stroke();
                     
                     // é‡ç½®é˜´å½±
                     ctx.shadowBlur = 0;
                     
                     // ç»˜åˆ¶å°¸ä½“é£Ÿç‰©å›¾ç‰‡
                     if (corpseImage && corpseImage.complete) {
                         // åˆ›å»ºåœ†å½¢è£å‰ªåŒºåŸŸ
                         ctx.beginPath();
                         ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                         ctx.clip();
                         
                         ctx.drawImage(corpseImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                     } else {
                         // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨é»˜è®¤è¡¨æƒ…
                         ctx.fillStyle = '#FFFFFF';
                         ctx.font = `bold ${gridSize * 0.6}px "Comic Sans MS", cursive`;
                         ctx.textAlign = 'center';
                         ctx.textBaseline = 'middle';
                         ctx.fillText(corpseFood.meme, 0, 0);
                     }
                     
                     // æ¢å¤ä¸Šä¸‹æ–‡
                     ctx.restore();
                 });
             }
             
             // ç»˜åˆ¶ç‰¹æ®Šé£Ÿç‰©ï¼ˆé—ªçƒæ•ˆæœï¼‰
             if (specialFood) {
                 // é—ªçƒæ•ˆæœ
                 const opacity = 0.5 + Math.sin(Date.now() / 100) * 0.5;
                 
                 ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                 ctx.shadowColor = 'white';
                 ctx.shadowBlur = 20;
                 
                 // æ—‹è½¬åŠ¨ç”»
                 ctx.save();
                 ctx.translate(specialFood.x + gridSize / 2, specialFood.y + gridSize / 2);
                 ctx.rotate(Date.now() / 500);
                 
                 ctx.beginPath();
                 ctx.rect(-gridSize / 2, -gridSize / 2, gridSize, gridSize);
                 ctx.fill();
                 
                 // ç‰¹æ®Šç¬¦å·
                 ctx.fillStyle = 'gold';
                 ctx.font = `${gridSize * 0.7}px "Comic Sans MS", cursive`;
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.fillText(specialFood.meme, 0, 0);
                 
                 ctx.restore();
                 ctx.shadowBlur = 0;
             }
        }
        
        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            if (isGameRunning) return;
            
            // éªŒè¯é’±åŒ…åœ°å€
            const walletAddress = playerNameInput.value.trim();
            if (!walletAddress) {
                alert('Please enter wallet address!');
                return;
            }
            
            // éªŒè¯é’±åŒ…åœ°å€æ ¼å¼
            if (!walletAddress.match(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)) {
                alert('Please enter a valid Solana wallet address!');
                return;
            }
            
            startScreen.classList.add('hidden');
            pauseBtn.classList.remove('hidden');
            roomSwitchBtn.classList.remove('hidden');
            isGameRunning = true;
            isPaused = false;
            
            // å¼€å§‹æ’­æ”¾èƒŒæ™¯éŸ³ä¹
            startBackgroundMusic();
            
            // åˆå§‹åŒ–æ¸¸æˆ
            initGame();
            
            // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
            database.ref('gameState').once('value', (snapshot) => {
                if (snapshot.exists()) {
                    const gameState = snapshot.val();
                    if (gameState.isRunning) {
                        // æ¸¸æˆæ­£åœ¨è¿è¡Œï¼Œå¼€å§‹æ¸¸æˆå¾ªç¯
                        gameLoop = setInterval(gameUpdate, gameSpeed);
                    } else {
                        // æ¸¸æˆè¢«æš‚åœï¼Œæ˜¾ç¤ºæš‚åœæ¶ˆæ¯
                        showGamePausedMessage();
                    }
                } else {
                    // æ²¡æœ‰æ¸¸æˆçŠ¶æ€ï¼Œé»˜è®¤å¼€å§‹
                    gameLoop = setInterval(gameUpdate, gameSpeed);
                }
            });
        }
        
        // åˆ‡æ¢æˆ¿é—´
        function switchRoom() {
            if (!isGameRunning) return;
            
            // æš‚åœæ¸¸æˆ
            isPaused = true;
            
            // ç§»é™¤å½“å‰æˆ¿é—´çš„ç©å®¶æ•°æ®
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).remove();
            }
            
            // æ˜¾ç¤ºæˆ¿é—´é€‰æ‹©
            startScreen.classList.remove('hidden');
            pauseBtn.classList.add('hidden');
            roomSwitchBtn.classList.add('hidden');
            
            // åœæ­¢æ¸¸æˆå¾ªç¯
            clearInterval(gameLoop);
            isGameRunning = false;
            
            // æ¸…ç©ºé’±åŒ…åœ°å€è¾“å…¥æ¡†ï¼Œè®©ç”¨æˆ·é‡æ–°è¾“å…¥
            playerNameInput.value = '';
        }
        
        // æš‚åœ/ç»§ç»­æ¸¸æˆ
        function togglePause() {
            if (!isGameRunning) return;
            
            isPaused = !isPaused;
            pauseBtn.innerHTML = isPaused ? 
                '<i class="fa fa-play text-xl"></i>' : 
                '<i class="fa fa-pause text-xl"></i>';
            
            // æš‚åœ/æ¢å¤éŸ³ä¹
            if (isPaused && isMusicPlaying) {
                bgMusic.pause();
            } else if (!isPaused && !isMusicPlaying) {
                bgMusic.play();
            }
        }
        
        // æ¸¸æˆç»“æŸ
        function gameOver() {
            clearInterval(gameLoop);
            isGameRunning = false;
            gameOverScreen.classList.remove('hidden');
            pauseBtn.classList.add('hidden');
            
            // å°†æ­»äº¡çš„è›‡èº«ä½“å˜æˆå°¸ä½“é£Ÿç‰©
            createCorpseFoods();
            
            // æ›´æ–°ç©å®¶çŠ¶æ€ä¸ºæ­»äº¡
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).update({
                    alive: false
                });
            }
            
            // ä¿å­˜æœ€é«˜åˆ†åˆ°æ’è¡Œæ¦œ
            saveHighScore();
            
            // è·å–å¹¶æ˜¾ç¤ºå½“å‰æ’è¡Œæ¦œ
            database.ref(`rooms/${gameRoom}/leaderboard`).once('value', (snapshot) => {
                const leaderboard = snapshot.val() || [];
                updateLeaderboardDisplay(leaderboard);
            });
        }
        
        // åˆ›å»ºå°¸ä½“é£Ÿç‰©
        function createCorpseFoods() {
            if (snake && snake.length > 0) {
                const gridSize = 15; // å›ºå®šç½‘æ ¼å¤§å°
                const newCorpseFoods = [];
                
                // éšæœºé€‰æ‹©memeè¡¨æƒ…
                const memeEmojis = ['ğŸ’€', 'â˜ ï¸', 'ğŸ‘»', 'ğŸ¤¡', 'ğŸ˜µ', 'ğŸ’©', 'ğŸ”¥', 'âš°ï¸', 'ğŸª¦', 'ğŸ§Ÿ'];
                const memeColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'];
                
                // å°†è›‡èº«ä½“çš„æ¯ä¸ªéƒ¨åˆ†å˜æˆå°¸ä½“é£Ÿç‰©
                snake.forEach((segment, index) => {
                    // ç¡®ä¿å°¸ä½“é£Ÿç‰©åœ¨æœ‰æ•ˆæ¸¸æˆåŒºåŸŸå†…
                    const canvasWidth = 1200;
                    const canvasHeight = 960;
                    const margin = Math.floor(canvasWidth * 0.05); // 60pxè¾¹è·
                    const effectiveWidth = canvasWidth - 2 * margin;
                    const effectiveHeight = canvasHeight - 2 * margin;
                    
                    // è®¡ç®—ç½‘æ ¼åæ ‡
                    const gridX = Math.floor((segment.x - margin) / gridSize);
                    const gridY = Math.floor((segment.y - margin) / gridSize);
                    
                    // ç¡®ä¿åœ¨æœ‰æ•ˆèŒƒå›´å†…
                    const maxGridX = Math.floor(effectiveWidth / gridSize) - 1;
                    const maxGridY = Math.floor(effectiveHeight / gridSize) - 1;
                    
                    const clampedGridX = Math.max(0, Math.min(gridX, maxGridX));
                    const clampedGridY = Math.max(0, Math.min(gridY, maxGridY));
                    
                    // è½¬æ¢å›åƒç´ åæ ‡
                    const clampedX = margin + clampedGridX * gridSize;
                    const clampedY = margin + clampedGridY * gridSize;
                    
                    const randomMeme = memeEmojis[Math.floor(Math.random() * memeEmojis.length)];
                    const randomColor = memeColors[Math.floor(Math.random() * memeColors.length)];
                    
                    const corpseFood = {
                        x: clampedX,
                        y: clampedY,
                        color: randomColor, // éšæœºmemeé¢œè‰²
                        meme: randomMeme,
                        timestamp: Date.now(),
                        id: 'corpse_' + Date.now() + '_' + index,
                        // ç§»é™¤ç©å®¶åå­—ï¼Œä¸å†æ˜¾ç¤º
                        originalColor: playerColor || '#FF3333',
                        rotation: Math.random() * 360, // éšæœºæ—‹è½¬è§’åº¦
                        pulse: Math.random() * 2 + 1, // éšæœºè„‰å†²é€Ÿåº¦
                        wiggle: Math.random() * 10 - 5 // éšæœºæ‘†åŠ¨å¹…åº¦
                    };
                    newCorpseFoods.push(corpseFood);
                });
                
                // è·å–ç°æœ‰çš„å°¸ä½“é£Ÿç‰©å¹¶æ·»åŠ æ–°çš„
                database.ref(`rooms/${gameRoom}/corpseFoods`).once('value', (snapshot) => {
                    const existingCorpseFoods = snapshot.val() || [];
                    const allCorpseFoods = [...existingCorpseFoods, ...newCorpseFoods];
                    database.ref(`rooms/${gameRoom}/corpseFoods`).set(allCorpseFoods);
                });
            }
        }
        
        // ä¿å­˜æœ€é«˜åˆ†åˆ°æ’è¡Œæ¦œ
        function saveHighScore() {
            const leaderboardRef = database.ref(`rooms/${gameRoom}/leaderboard`);
            leaderboardRef.once('value', (snapshot) => {
                let leaderboard = snapshot.val() || [];
                
                // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨è¯¥ç©å®¶çš„è®°å½•
                const existingIndex = leaderboard.findIndex(entry => entry.playerId === playerId);
                
                if (existingIndex !== -1) {
                    // æ›´æ–°ç°æœ‰è®°å½•
                    if (score > leaderboard[existingIndex].score) {
                        leaderboard[existingIndex] = {
                            playerId: playerId,
                            playerName: playerName,
                            wallet: playerWallet,
                            score: score,
                            timestamp: Date.now()
                        };
                    }
                } else {
                    // æ·»åŠ æ–°è®°å½•
                    leaderboard.push({
                        playerId: playerId,
                        playerName: playerName,
                        wallet: playerWallet,
                        score: score,
                        timestamp: Date.now()
                    });
                }
                
                // æŒ‰åˆ†æ•°é™åºæ’åº
                leaderboard.sort((a, b) => b.score - a.score);
                
                // åªä¿ç•™å‰10å
                leaderboard = leaderboard.slice(0, 10);
                
                // ä¿å­˜åˆ°æ•°æ®åº“
                leaderboardRef.set(leaderboard);
            });
        }
        
        // æ˜¾ç¤ºé¢†å–å¥–åŠ±å¼¹çª—
        function showClaimRewardModal() {
            const modal = document.getElementById('claimRewardModal');
            modal.classList.remove('hidden');
            
            // å¦‚æœå½“å‰æœ‰ç©å®¶é’±åŒ…åœ°å€ï¼Œè‡ªåŠ¨å¡«å……
            if (playerWallet) {
                document.getElementById('walletAddressInput').value = playerWallet;
            }
        }
        
        // éšè—é¢†å–å¥–åŠ±å¼¹çª—
        function hideClaimRewardModal() {
            const modal = document.getElementById('claimRewardModal');
            modal.classList.add('hidden');
            document.getElementById('claimResult').classList.add('hidden');
        }
        
        // æŸ¥çœ‹ç§¯åˆ†
        async function checkScore() {
            const walletAddress = document.getElementById('walletAddressInput').value.trim();
            if (!walletAddress) {
                showClaimResult('Please enter wallet address', 'error');
                return;
            }
            
            try {
                const userRef = database.ref(`users/${walletAddress}`);
                const snapshot = await userRef.once('value');
                const userData = snapshot.val();
                const totalScore = userData ? (userData.score || 0) : 0;
                
                document.getElementById('totalScore').textContent = totalScore;
                document.getElementById('tokenAmount').textContent = totalScore * 10; // 1ç§¯åˆ† = 10ä»£å¸
                
                showClaimResult(`Query successful! Wallet ${walletAddress.substring(0, 8)}...${walletAddress.substring(walletAddress.length - 4)} has ${totalScore} points`, 'success');
            } catch (error) {
                showClaimResult('Failed to query points: ' + error.message, 'error');
            }
        }
        
        // å…‘æ¢ä»£å¸
        async function claimToken() {
            const walletAddress = document.getElementById('walletAddressInput').value.trim();
            if (!walletAddress) {
                showClaimResult('Please enter wallet address', 'error');
                return;
            }
            
            try {
                showClaimResult('Processing claim request...', 'info');
                
                const result = await claimTokenFunction({ wallet: walletAddress });
                
                if (result.data.success) {
                    // éšè—å½“å‰å¼¹çª—
                    hideClaimRewardModal();
                    
                    // è·å–å®é™…å…‘æ¢çš„ç§¯åˆ†æ•°é‡
                    const scoreAmount = parseInt(document.getElementById('totalScore').textContent) || 0;
                    const tokenAmount = scoreAmount * 10; // 1ç§¯åˆ† = 10ä»£å¸
                    
                    // æ˜¾ç¤ºæˆåŠŸå¼¹çª—
                    showSuccessModal(result.data.tx, tokenAmount);
                    
                    // åˆ·æ–°ç§¯åˆ†æ˜¾ç¤º
                    setTimeout(() => {
                        checkScore();
                    }, 1000);
                } else {
                    showClaimResult('Claim failed: ' + (result.data.message || 'Unknown error'), 'error');
                }
            } catch (error) {
                showClaimResult('Claim failed: ' + error.message, 'error');
            }
        }
        
        // æ˜¾ç¤ºç»“æœä¿¡æ¯
        function showClaimResult(message, type) {
            const resultDiv = document.getElementById('claimResult');
            resultDiv.className = `mt-4 p-3 rounded ${type === 'success' ? 'bg-green-600' : type === 'error' ? 'bg-red-600' : 'bg-blue-600'} text-white`;
            resultDiv.textContent = message;
            resultDiv.classList.remove('hidden');
        }
        
        // æ˜¾ç¤ºå…‘æ¢æˆåŠŸå¼¹çª—
        function showSuccessModal(txHash, amount) {
            // åˆ›å»ºæˆåŠŸå¼¹çª—
            const successModal = document.createElement('div');
            successModal.className = 'fixed inset-0 bg-black/80 flex items-center justify-center z-50';
            successModal.innerHTML = `
                <div class="bg-gray-800 p-6 rounded-lg border-2 border-memeGreen max-w-md w-full mx-4">
                    <div class="text-center">
                        <div class="text-6xl mb-4">ğŸ‰</div>
                        <h3 class="text-2xl font-bold text-memeGreen mb-4">Claim Successful!</h3>
                        <div class="mb-4 p-3 bg-gray-700 rounded">
                            <div class="text-lg font-bold text-memeYellow mb-2">${amount} Tokens</div>
                            <div class="text-sm text-gray-400">Sent to your wallet</div>
                        </div>
                        <div class="mb-4 p-3 bg-gray-700 rounded text-left">
                            <div class="text-sm text-gray-400 mb-1">Transaction Hash:</div>
                            <div class="text-xs text-memeBlue break-all font-mono">${txHash}</div>
                        </div>
                        <div class="mb-4 text-sm text-gray-400">
                            You can view transaction details in Solana Explorer
                        </div>
                        <button class="bg-memeGreen hover:bg-memeGreen/80 text-black py-2 px-6 rounded font-bold" onclick="this.parentElement.parentElement.parentElement.remove()">
                            OK
                        </button>
                    </div>
                </div>
            `;
            
            // æ·»åŠ åˆ°é¡µé¢
            document.body.appendChild(successModal);
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­å¼¹çª—
            successModal.addEventListener('click', (e) => {
                if (e.target === successModal) {
                    successModal.remove();
                }
            });
        }
        
        // é‡å¯æ¸¸æˆ
        function restartGame() {
            // ç§»é™¤æ—§ç©å®¶æ•°æ®
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).remove();
            }
            
            gameOverScreen.classList.add('hidden');
            
            // é‡æ–°æ˜¾ç¤ºå¼€å§‹å±å¹•ï¼Œè®©ç”¨æˆ·é‡æ–°è¾“å…¥é’±åŒ…åœ°å€
            startScreen.classList.remove('hidden');
            pauseBtn.classList.add('hidden');
            roomSwitchBtn.classList.add('hidden');
            isGameRunning = false;
            isPaused = false;
            
            // æ¸…ç©ºé’±åŒ…åœ°å€è¾“å…¥æ¡†
            playerNameInput.value = '';
        }
        
        // å¤„ç†é”®ç›˜è¾“å…¥
        function handleKeyPress(e) {
            // é˜»æ­¢æ–¹å‘é”®æ»šåŠ¨é¡µé¢
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
            
            // åªåœ¨æ¸¸æˆè¿è¡Œæ—¶å¤„ç†æ–¹å‘é”®ï¼Œæˆ–è€…å¤„ç†ç©ºæ ¼é”®
            if (!isGameRunning && e.key !== ' ') return;
            
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction !== 'down') {
                        nextDirection = 'up';
                    }
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction !== 'up') {
                        nextDirection = 'down';
                    }
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction !== 'right') {
                        nextDirection = 'left';
                    }
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction !== 'left') {
                        nextDirection = 'right';
                    }
                    break;
                case ' ': // ç©ºæ ¼é”®æš‚åœ/ç»§ç»­
                    if (isGameRunning) {
                        togglePause();
                    } else if (!startScreen.classList.contains('hidden')) {
                        startGame();
                    }
                    break;
            }
        }
        
        // éŸ³ä¹æ§åˆ¶å‡½æ•°
        function startBackgroundMusic() {
            if (bgMusic && !isMusicPlaying) {
                bgMusic.volume = musicVolume;
                bgMusic.play().then(() => {
                    isMusicPlaying = true;
                    updateMusicUI();
                }).catch(error => {
                    console.log('Music autoplay failed:', error);
                    // ç”¨æˆ·äº¤äº’åå¯ä»¥æ’­æ”¾éŸ³ä¹
                });
            }
        }
        
        function toggleMusic() {
            if (!bgMusic) return;
            
            if (isMusicPlaying) {
                bgMusic.pause();
                isMusicPlaying = false;
            } else {
                bgMusic.play();
                isMusicPlaying = true;
            }
            updateMusicUI();
        }
        
        function updateMusicUI() {
            if (!musicBtn || !musicIndicator) return;
            
            if (isMusicPlaying) {
                musicBtn.innerHTML = '<i class="fa fa-music"></i>';
                musicBtn.classList.remove('muted');
                musicIndicator.classList.remove('muted');
            } else {
                musicBtn.innerHTML = '<i class="fa fa-volume-off"></i>';
                musicBtn.classList.add('muted');
                musicIndicator.classList.add('muted');
            }
        }
        
        function setMusicVolume(volume) {
            musicVolume = Math.max(0, Math.min(1, volume));
            if (bgMusic) {
                bgMusic.volume = musicVolume;
            }
        }
        
        function setSoundVolume(volume) {
            soundVolume = Math.max(0, Math.min(1, volume));
            if (eatSound) {
                eatSound.volume = soundVolume;
            }
        }
        
        function playEatSound() {
            if (eatSound) {
                eatSound.volume = soundVolume;
                eatSound.currentTime = 0; // é‡ç½®æ’­æ”¾ä½ç½®
                eatSound.play().catch(error => {
                    console.log('Sound effect play failed:', error);
                });
            }
        }
        
        // åˆå§‹åŒ–éŸ³ä¹æ§åˆ¶
        function initMusicControl() {
            if (musicBtn) {
                musicBtn.addEventListener('click', toggleMusic);
            }
            
            // è®¾ç½®åˆå§‹éŸ³é‡
            setMusicVolume(0.5);
            setSoundVolume(0.7);
            
            // æ›´æ–°UIçŠ¶æ€
            updateMusicUI();
        }
        
        // äº‹ä»¶ç›‘å¬
        document.addEventListener('keydown', handleKeyPress);
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', restartGame);
        pauseBtn.addEventListener('click', togglePause);
        roomSwitchBtn.addEventListener('click', switchRoom);
        
        // é¢†å–å¥–åŠ±ç›¸å…³äº‹ä»¶ç›‘å¬
        document.getElementById('claimRewardBtn').addEventListener('click', showClaimRewardModal);
        document.getElementById('closeClaimModal').addEventListener('click', hideClaimRewardModal);
        document.getElementById('checkScoreBtn').addEventListener('click', checkScore);
        document.getElementById('claimTokenBtn').addEventListener('click', claimToken);
        
        // æ’è¡Œæ¦œç›¸å…³äº‹ä»¶ç›‘å¬
        document.getElementById('viewLeaderboardBtn').addEventListener('click', showLeaderboardModal);
        document.getElementById('closeLeaderboardModal').addEventListener('click', hideLeaderboardModal);
        document.getElementById('refreshLeaderboardBtn').addEventListener('click', loadGlobalLeaderboard);
        document.getElementById('leaderboardRoomSelect').addEventListener('change', loadGlobalLeaderboard);
        
        // é¢œè‰²é€‰æ‹©
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // ç§»é™¤å…¶ä»–æŒ‰é’®çš„é€‰ä¸­çŠ¶æ€
                document.querySelectorAll('.color-btn').forEach(b => {
                    b.classList.remove('border-white');
                    b.classList.add('border-gray-600');
                });
                
                // é€‰ä¸­å½“å‰æŒ‰é’®
                btn.classList.remove('border-gray-600');
                btn.classList.add('border-white');
                
                // ä¿å­˜é€‰æ‹©çš„é¢œè‰²
                playerColor = btn.dataset.color;
            });
        });
        
        // ä¸é¢„å¡«å……é’±åŒ…åœ°å€ï¼Œè®©ç”¨æˆ·å¿…é¡»è¾“å…¥
        playerNameInput.value = '';
        
        // é»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ªé¢œè‰²
        document.querySelector('.color-btn').click();
        
        // æ’è¡Œæ¦œåŠŸèƒ½å‡½æ•°
        function showLeaderboardModal() {
            const modal = document.getElementById('leaderboardModal');
            modal.classList.remove('hidden');
            loadGlobalLeaderboard();
        }
        
        function hideLeaderboardModal() {
            const modal = document.getElementById('leaderboardModal');
            modal.classList.add('hidden');
        }
        
        async function loadGlobalLeaderboard() {
            const roomSelect = document.getElementById('leaderboardRoomSelect');
            const selectedRoom = roomSelect.value;
            const leaderboardList = document.getElementById('globalLeaderboardList');
            
            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            leaderboardList.innerHTML = '<div class="text-center text-gray-400">Loading leaderboard...</div>';
            
            try {
                let allLeaderboards = [];
                
                if (selectedRoom === 'all') {
                    // è·å–æ‰€æœ‰æˆ¿é—´çš„æ’è¡Œæ¦œ
                    const rooms = ['default', 'room1', 'room2', 'room3'];
                    const promises = rooms.map(room => 
                        database.ref(`rooms/${room}/leaderboard`).once('value')
                    );
                    
                    const results = await Promise.all(promises);
                    results.forEach((snapshot, index) => {
                        const leaderboard = snapshot.val() || [];
                        // ä¸ºæ¯ä¸ªæ¡ç›®æ·»åŠ æˆ¿é—´ä¿¡æ¯
                        leaderboard.forEach(entry => {
                            entry.room = rooms[index];
                        });
                        allLeaderboards = allLeaderboards.concat(leaderboard);
                    });
                } else {
                    // è·å–ç‰¹å®šæˆ¿é—´çš„æ’è¡Œæ¦œ
                    const snapshot = await database.ref(`rooms/${selectedRoom}/leaderboard`).once('value');
                    const leaderboard = snapshot.val() || [];
                    leaderboard.forEach(entry => {
                        entry.room = selectedRoom;
                    });
                    allLeaderboards = leaderboard;
                }
                
                // æŒ‰åˆ†æ•°é™åºæ’åº
                allLeaderboards.sort((a, b) => b.score - a.score);
                
                // åªæ˜¾ç¤ºå‰20å
                allLeaderboards = allLeaderboards.slice(0, 20);
                
                // æ˜¾ç¤ºæ’è¡Œæ¦œ
                displayGlobalLeaderboard(allLeaderboards);
                
            } catch (error) {
                console.error('Failed to load leaderboard:', error);
                leaderboardList.innerHTML = '<div class="text-center text-red-400">Failed to load leaderboard</div>';
            }
        }
        
        function displayGlobalLeaderboard(leaderboard) {
            const leaderboardList = document.getElementById('globalLeaderboardList');
            leaderboardList.innerHTML = '';
            
            if (leaderboard.length === 0) {
                leaderboardList.innerHTML = '<div class="text-center text-gray-400">No scores yet</div>';
                return;
            }
            
            leaderboard.forEach((entry, index) => {
                const row = document.createElement('div');
                row.className = 'grid grid-cols-4 gap-4 items-center py-2 border-b border-gray-600';
                
                // è®¾ç½®æ’åæ ·å¼
                let rankClass = 'text-gray-400';
                if (index === 0) rankClass = 'text-memeYellow font-bold';
                else if (index === 1) rankClass = 'text-gray-300 font-bold';
                else if (index === 2) rankClass = 'text-amber-700 font-bold';
                
                // æ ¼å¼åŒ–æ—¶é—´ (UTC)
                const date = new Date(entry.timestamp);
                const timeStr = `${date.getUTCMonth() + 1}/${date.getUTCDate()} ${date.getUTCHours()}:${date.getUTCMinutes().toString().padStart(2, '0')} UTC`;
                
                // æ ¼å¼åŒ–é’±åŒ…åœ°å€
                const shortWallet = entry.wallet ? 
                    `${entry.wallet.substring(0, 6)}...${entry.wallet.substring(entry.wallet.length - 4)}` : 
                    'Unknown';
                
                // æˆ¿é—´åç§°æ˜ å°„
                const roomNames = {
                    'default': 'Default',
                    'room1': 'Beginner',
                    'room2': 'Advanced',
                    'room3': 'Casual'
                };
                
                row.innerHTML = `
                    <div class="${rankClass} text-center">#${index + 1}</div>
                    <div class="text-white">
                        <div class="font-bold">${entry.playerName}</div>
                        <div class="text-xs text-gray-400">${shortWallet} â€¢ ${roomNames[entry.room] || entry.room}</div>
                    </div>
                    <div class="text-memeGreen font-bold text-center">${entry.score}</div>
                    <div class="text-gray-400 text-center text-sm">${timeStr}</div>
                `;
                
                leaderboardList.appendChild(row);
            });
        }
        
        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–æ’è¡Œæ¦œ
        document.addEventListener('DOMContentLoaded', () => {
            // åˆå§‹åŒ–éŸ³ä¹æ§åˆ¶
            initMusicControl();
            
            // å…¶ä»–åˆå§‹åŒ–ä»£ç ...
        });
    </script>
</body>
</html>
