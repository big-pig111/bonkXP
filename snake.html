<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Meme Snake Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-functions-compat.js"></script>
    
    <!-- Background Music -->
    <audio id="bgMusic" loop>
        <source src="1.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
    <!-- Sound Effects -->
    <audio id="eatSound" preload="auto">
        <source src="2.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
    <style type="text/tailwindcss">
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        .font-meme {
            font-family: 'Orbitron', monospace;
        }
        
        .text-memeRed { color: #FF3333; }
        .text-memeBlue { color: #0066FF; }
        .text-memeGreen { color: #33CC33; }
        .text-memeYellow { color: #FFE100; }
        .text-memePink { color: #FF66CC; }
        
        .bg-memeRed { background-color: #FF3333; }
        .bg-memeBlue { background-color: #0066FF; }
        .bg-memeGreen { background-color: #33CC33; }
        .bg-memeYellow { background-color: #FFE100; }
        .bg-memePink { background-color: #FF66CC; }
        
        .border-memeRed { border-color: #FF3333; }
        .border-memeBlue { border-color: #0066FF; }
        .border-memeGreen { border-color: #33CC33; }
        .border-memeYellow { border-color: #FFE100; }
        .border-memePink { border-color: #FF66CC; }
        
        .hover\:bg-memeRed:hover { background-color: #FF3333; }
        .hover\:bg-memeBlue:hover { background-color: #0066FF; }
        .hover\:bg-memeGreen:hover { background-color: #33CC33; }
        .hover\:bg-memeYellow:hover { background-color: #FFE100; }
        .hover\:bg-memePink:hover { background-color: #FF66CC; }
        
        .bounce-meme {
            animation: bounce 1s infinite;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }
        
        .pulse-meme {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }
        
        /* Music Control Floating Window Styles */
        .music-control {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #FFE100;
            border-radius: 15px;
            padding: 10px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .music-control:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 225, 0, 0.5);
        }
        
        .music-btn {
            background: linear-gradient(45deg, #FFE100, #FF9900);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            color: #000;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .music-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 225, 0, 0.7);
        }
        
        .music-btn.muted {
            background: linear-gradient(45deg, #666, #999);
            color: #fff;
        }
        
        .music-indicator {
                position: absolute;
            top: -5px;
            right: -5px;
            width: 15px;
            height: 15px;
            background: #33CC33;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        
        .music-indicator.muted {
            background: #FF3333;
            animation: none;
        }
        
        .wiggle {
            animation: wiggle 0.5s ease-in-out infinite;
        }
        
        .countdown-animation {
            animation: countdownPulse 1s ease-in-out;
        }
        
        @keyframes countdownPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body class="bg-gray-900 font-meme min-h-screen flex flex-col items-center justify-center p-4 text-white overflow-x-hidden">
    
    <!-- Music Control Floating Window -->
    <div class="music-control" id="musicControl">
        <div class="music-indicator" id="musicIndicator"></div>
        <button class="music-btn" id="musicBtn" title="Toggle Music">
            <i class="fa fa-music"></i>
        </button>
    </div>
    <!-- Page Title -->
    <header class="text-center mb-6 relative">
        <h1 class="text-[clamp(2rem,5vw,4rem)] font-bold text-memeYellow glow mb-2 transform -rotate-2">
            <i class="fa fa-users mr-2"></i> Multiplayer MEME Snake <i class="fa fa-users ml-2"></i>
        </h1>
        <p class="text-memePink text-[clamp(1rem,2vw,1.5rem)] wiggle">
            Eat together, grow together with friends!
        </p>
    </header>

         <!-- Game Container -->
             <main class="relative w-full max-w-7xl">
        <!-- Player Info and Score Panel -->
        <div class="flex flex-wrap justify-between items-center mb-4 gap-4">
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-user text-memeBlue mr-2"></i>
                    <span class="text-xl">Player: <span id="playerName" class="text-memeGreen font-bold">Anonymous</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-star text-memeYellow mr-2"></i>
                    <span class="text-xl">Score: <span id="score" class="text-memeGreen font-bold">0</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-users text-memePink mr-2"></i>
                    <span class="text-xl">Online: <span id="playerCount" class="text-memeBlue font-bold">0</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-gamepad text-memeRed mr-2"></i>
                    <span class="text-xl">Room: <span id="roomName" class="text-memeBlue font-bold">Default Room</span></span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeYellow flex-1 min-w-[200px]">
                <div class="flex items-center">
                    <i class="fa fa-clock text-memePink mr-2"></i>
                    <span class="text-xl" id="countdown">Next Reset: --:--</span>
                </div>
            </div>
            <div class="bg-gray-800 p-3 rounded-lg border-2 border-memeGreen flex-1 min-w-[200px]">
                <div class="flex items-center justify-between">
                    <div class="flex items-center">
                        <i class="fa fa-gift text-memeGreen mr-2"></i>
                        <span class="text-xl">My Points</span>
                    </div>
                    <button id="claimRewardBtn" class="bg-memeGreen hover:bg-memeGreen/80 text-black px-3 py-1 rounded text-sm font-bold">
                        Claim Rewards
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Game Canvas Container -->
        <div class="relative border-4 border-memePink rounded-lg overflow-hidden bg-gray-800 shadow-lg">
            <canvas id="gameCanvas" class="w-full h-auto bg-gray-900"></canvas>
            
            <!-- Start Screen -->
            <div id="startScreen" class="absolute inset-0 bg-gray-900/90 flex flex-col items-center justify-center z-10">
                <h2 class="text-4xl font-bold text-memeYellow mb-6 bounce-meme">Ready to play with friends?</h2>
                <div class="mb-4 w-full max-w-xs">
                    <label for="playerNameInput" class="block text-left mb-2 text-memeGreen">Your Wallet Address</label>
                    <input type="text" id="playerNameInput" 
                           class="w-full bg-gray-700 border border-memeBlue rounded p-2 text-white font-meme"
                           placeholder="Enter your Solana wallet address">
                </div>
                <div class="mb-4 w-full max-w-xs">
                    <label for="roomSelect" class="block text-left mb-2 text-memeBlue">Select Room</label>
                    <select id="roomSelect" class="w-full bg-gray-700 border border-memeBlue rounded p-2 text-white font-meme">
                        <option value="default">Default Room (0/10)</option>
                        <option value="room1">Room 1 - Beginner (0/10)</option>
                        <option value="room2">Room 2 - Advanced (0/10)</option>
                        <option value="room3">Room 3 - Casual (0/10)</option>
                    </select>
                </div>
                <div class="mb-6 w-full max-w-xs">
                    <label class="block text-left mb-2 text-memePink">Choose Color</label>
                    <div class="flex gap-2 flex-wrap">
                        <button class="color-btn w-8 h-8 rounded-full bg-memeRed border-2 border-white" data-color="#FF3333"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memeBlue border-2" data-color="#0066FF"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memeGreen border-2" data-color="#33CC33"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memeYellow border-2" data-color="#FFE100"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-memePink border-2" data-color="#FF66CC"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-orange-500 border-2" data-color="#FF9900"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-purple-500 border-2" data-color="#9966FF"></button>
                        <button class="color-btn w-8 h-8 rounded-full bg-cyan-500 border-2" data-color="#66CCFF"></button>
                    </div>
                </div>
                <button id="startBtn" class="bg-memeRed hover:bg-memeRed/80 text-white text-2xl py-3 px-8 rounded-full transform transition-transform hover:scale-110 active:scale-95 font-bold shadow-lg">
                    Join Game <i class="fa fa-play ml-2"></i>
                </button>
            </div>
            
            <!-- Game Over Screen -->
            <div id="gameOverScreen" class="absolute inset-0 bg-gray-900/95 flex flex-col items-center justify-center z-10 hidden">
                <h2 class="text-5xl font-bold text-memeRed mb-4 wiggle">Game Over!</h2>
                <p class="text-2xl mb-2">Your Score: <span id="finalScore" class="text-memeGreen font-bold">0</span></p>
                <p class="text-xl mb-4">Leaderboard:</p>
                <ul id="leaderboard" class="mb-8 bg-gray-800 p-4 rounded-lg w-64">
                    <!-- Leaderboard will be generated here -->
                </ul>
                <button id="restartBtn" class="bg-memeGreen hover:bg-memeGreen/80 text-white text-2xl py-3 px-8 rounded-full transform transition-transform hover:scale-110 active:scale-95 font-bold shadow-lg">
                    Play Again <i class="fa fa-refresh ml-2"></i>
                </button>
            </div>
            
            <!-- Game Countdown Screen -->
            <div id="countdownScreen" class="absolute inset-0 bg-gray-900/90 flex items-center justify-center z-15 hidden">
                <div class="text-center">
                    <div id="countdownNumber" class="text-8xl font-bold text-memeYellow mb-4 countdown-animation">3</div>
                    <div class="text-2xl text-white">Get Ready!</div>
                </div>
            </div>
            
            <!-- Pause Button -->
            <button id="pauseBtn" class="absolute top-4 right-4 bg-gray-800/70 hover:bg-gray-700 text-white p-2 rounded-full z-5 hidden">
                <i class="fa fa-pause text-xl"></i>
            </button>
            
            <!-- Room Switch Button -->
            <button id="roomSwitchBtn" class="absolute top-4 left-4 bg-gray-800/70 hover:bg-gray-700 text-white p-2 rounded-full z-5 hidden">
                <i class="fa fa-exchange text-xl"></i>
            </button>
            
            <!-- ÈÇÄËØ∑ÊåâÈíÆÂ∑≤ÁßªËá≥È¢ÜÂèñÂ•ñÂä±ÁïåÈù¢ -->
            
            <!-- Claim Rewards Modal -->
            <div id="claimRewardModal" class="absolute inset-0 bg-gray-900/95 flex items-center justify-center z-20 hidden">
                <div class="bg-gray-800 p-6 rounded-lg border-2 border-memeGreen max-w-md w-full mx-4">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-2xl font-bold text-memeGreen">Claim Rewards</h3>
                        <button id="closeClaimModal" class="text-gray-400 hover:text-white text-xl">
                            <i class="fa fa-times"></i>
                        </button>
                    </div>
                    
                    <div class="mb-4">
                        <label for="walletAddressInput" class="block text-left mb-2 text-memeBlue">Wallet Address</label>
                        <input type="text" id="walletAddressInput" 
                               class="w-full bg-gray-700 border border-memeBlue rounded p-2 text-white font-meme"
                               placeholder="Enter your Solana wallet address">
                    </div>
                    
                    <div class="mb-4 p-3 bg-gray-700 rounded">
                        <div class="text-center">
                            <div class="text-3xl font-bold text-memeYellow" id="totalScore">0</div>
                            <div class="text-sm text-gray-400">Total Points</div>
                        </div>
                    </div>
                    
                    <div class="mb-4 p-3 bg-gray-700 rounded">
                        <div class="text-center">
                            <div class="text-lg font-bold text-memeGreen" id="tokenAmount">0</div>
                            <div class="text-sm text-gray-400">Tokens Available</div>
                        </div>
                    </div>
                    
                    <div class="flex gap-2 mb-4">
                        <button id="checkScoreBtn" class="flex-1 bg-memeBlue hover:bg-memeBlue/80 text-white py-2 px-4 rounded font-bold">
                            Check Points
                        </button>
                        <button id="claimTokenBtn" class="flex-1 bg-memeGreen hover:bg-memeGreen/80 text-black py-2 px-4 rounded font-bold">
                            Claim Tokens
                        </button>
                    </div>
                    
                    <div class="flex gap-2 mb-4">
                        <button id="viewLeaderboardBtn" class="flex-1 bg-memePink hover:bg-memePink/80 text-white py-2 px-4 rounded font-bold">
                            <i class="fa fa-trophy mr-2"></i>Global Leaderboard
                        </button>
                        <button id="inviteSystemBtn" class="flex-1 bg-memeYellow hover:bg-yellow-500 text-black py-2 px-4 rounded font-bold">
                            <i class="fa fa-users mr-2"></i>Invite System
                        </button>
                    </div>
                    
                    <div id="claimResult" class="mt-4 p-3 rounded hidden">
                        <!-- Result display area -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Invite System Modal -->
        <div id="inviteModal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50 hidden">
            <div class="bg-gray-800 p-6 rounded-lg border-2 border-memeYellow max-w-md w-full mx-4">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-memeYellow">üë• Invite System</h2>
                    <button id="closeInviteModal" class="text-gray-400 hover:text-white text-2xl">√ó</button>
                </div>
                
                <!-- My Invite Code Section -->
                <div class="mb-6">
                    <h3 class="text-lg font-bold text-white mb-2">My Invite Code</h3>
                    <div class="bg-gray-700 p-3 rounded-lg mb-2">
                        <div class="flex items-center justify-between">
                            <span id="myInviteCode" class="text-memeYellow font-mono text-lg">--------</span>
                            <button id="copyInviteBtn" class="bg-memeYellow text-black px-3 py-1 rounded hover:bg-yellow-500 text-sm">
                                <i class="fa fa-copy"></i> Copy
                            </button>
                        </div>
                    </div>
                    <p class="text-gray-400 text-sm">Share your invite code, each valid user you invite gets permanent 10% bonus points!</p>
                </div>
                
                <!-- Enter Invite Code Section -->
                <div class="mb-6">
                    <h3 class="text-lg font-bold text-white mb-2">Enter Invite Code</h3>
                    <div class="flex gap-2">
                        <input type="text" id="inviteCodeInput" placeholder="Enter 8-digit invite code" 
                               class="flex-1 bg-gray-700 text-white px-3 py-2 rounded border border-gray-600 focus:border-memeYellow focus:outline-none"
                               maxlength="8">
                        <button id="submitInviteBtn" class="bg-memeGreen text-white px-4 py-2 rounded hover:bg-green-600">
                            Submit
                        </button>
                    </div>
                    <p class="text-gray-400 text-sm mt-1">You can only submit once, after which you start as a valid user</p>
                </div>
                
                <!-- Invite Stats Section -->
                <div class="mb-4">
                    <h3 class="text-lg font-bold text-white mb-2">Invite Stats</h3>
                    <div class="grid grid-cols-2 gap-4">
                        <div class="bg-gray-700 p-3 rounded text-center">
                            <div class="text-memeGreen text-xl font-bold" id="invitedCount">0</div>
                            <div class="text-gray-400 text-sm">Invited</div>
                        </div>
                        <div class="bg-gray-700 p-3 rounded text-center">
                            <div class="text-memeYellow text-xl font-bold" id="bonusPercent">0%</div>
                            <div class="text-gray-400 text-sm">Bonus Points</div>
                        </div>
                    </div>
                </div>
                
                <!-- Current Status -->
                <div class="text-center">
                    <p class="text-gray-400 text-sm" id="inviteStatus">Loading...</p>
                </div>
            </div>
        </div>
        
        <!-- Global Leaderboard Modal -->
        <div id="leaderboardModal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50 hidden">
            <div class="bg-gray-800 p-6 rounded-lg border-2 border-memePink max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-2xl font-bold text-memePink">
                        <i class="fa fa-trophy mr-2"></i>Global Leaderboard
                    </h3>
                    <button id="closeLeaderboardModal" class="text-gray-400 hover:text-white text-xl">
                        <i class="fa fa-times"></i>
                    </button>
                </div>
                
                <div class="mb-4">
                    <div class="flex gap-2 mb-4">
                        <select id="leaderboardRoomSelect" class="flex-1 bg-gray-700 border border-memePink rounded p-2 text-white">
                            <option value="all">All Rooms</option>
                            <option value="default">Default Room</option>
                            <option value="room1">Room 1 - Beginner</option>
                            <option value="room2">Room 2 - Advanced</option>
                            <option value="room3">Room 3 - Casual</option>
                        </select>
                        <button id="refreshLeaderboardBtn" class="bg-memePink hover:bg-memePink/80 text-white py-2 px-4 rounded font-bold">
                            <i class="fa fa-refresh mr-2"></i>Refresh
                        </button>
                    </div>
                </div>
                
                <div class="bg-gray-700 rounded p-4">
                    <div class="grid grid-cols-4 gap-4 mb-4 text-center text-sm font-bold text-memePink">
                        <div>Rank</div>
                        <div>Player</div>
                        <div>Score</div>
                        <div>Date</div>
                    </div>
                    <div id="globalLeaderboardList" class="space-y-2">
                        <!-- Leaderboard entries will be loaded here -->
                    </div>
                </div>
                
                <div class="mt-4 text-center text-sm text-gray-400">
                    <p>üèÜ Top players across all rooms</p>
                    <p>üíé Scores are updated in real-time</p>
                </div>
            </div>
        </div>
        
        <!-- Game Controls and Player List -->
        <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div class="bg-gray-800 p-4 rounded-lg border border-memeBlue">
                <h3 class="text-memeBlue text-xl font-bold mb-2">Game Instructions</h3>
                <ul class="list-disc pl-5 space-y-1">
                    <li>Eat food to make the snake longer</li>
                    <li>Hitting walls, yourself, or other players will cause death</li>
                    <li>Higher scores mean faster speed</li>
                    <li>Special foods have surprises!</li>
                    <li>Press Space to pause/continue</li>
                </ul>
            </div>
            <div class="bg-gray-800 p-4 rounded-lg border border-memeGreen">
                <h3 class="text-memeGreen text-xl font-bold mb-2">Current Players</h3>
                <ul id="playersList" class="space-y-2 max-h-32 overflow-y-auto">
                    <!-- Player list will be generated here -->
                </ul>
            </div>
        </div>
        
        <!-- Room Statistics -->
        <div class="mt-4 bg-gray-800 p-4 rounded-lg border border-memeYellow">
            <h3 class="text-memeYellow text-xl font-bold mb-2">Room Statistics</h3>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="text-center">
                    <div class="text-2xl font-bold text-memeGreen" id="totalPlayers">0</div>
                    <div class="text-sm text-gray-400">Total Players</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-memeBlue" id="activePlayers">0</div>
                    <div class="text-sm text-gray-400">Active Players</div>
                </div>
                <div class="text-center">
                    <div class="text-2xl font-bold text-memeRed" id="roomHighScore">0</div>
                    <div class="text-sm text-gray-400">Room High Score</div>
                </div>
            </div>
        </div>
        

    </main>
    
    <!-- Footer -->
    <footer class="mt-8 text-center text-gray-500 text-sm">
        <p>¬© 2023 Multiplayer Meme Snake | Real-time sync with Firebase <i class="fa fa-bolt text-memeYellow"></i></p>
    </footer>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyA5Z5ieEbAcfQX0kxGSn9ldGXhzvAwx_8M",
            authDomain: "chat-294cc.firebaseapp.com",
            databaseURL: "https://chat-294cc-default-rtdb.firebaseio.com",
            projectId: "chat-294cc",
            storageBucket: "chat-294cc.firebasestorage.app",
            messagingSenderId: "913615304269",
            appId: "1:913615304269:web:0274ffaccb8e6b678e4e04",
            measurementId: "G-SJR9NDW86B"
        };

        // Initialize Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const functions = firebase.functions();
        
        // Game Constants and Variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const playerCountElement = document.getElementById('playerCount');
        const playerNameElement = document.getElementById('playerName');
        const finalScoreElement = document.getElementById('finalScore');
        const leaderboardElement = document.getElementById('leaderboard');
        const playersListElement = document.getElementById('playersList');
        const roomNameElement = document.getElementById('roomName');
        const totalPlayersElement = document.getElementById('totalPlayers');
        const activePlayersElement = document.getElementById('activePlayers');
        const roomHighScoreElement = document.getElementById('roomHighScore');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const roomSwitchBtn = document.getElementById('roomSwitchBtn');
        const playerNameInput = document.getElementById('playerNameInput');
        const roomSelect = document.getElementById('roomSelect');
        
        // Music Control Elements
        const bgMusic = document.getElementById('bgMusic');
        const musicBtn = document.getElementById('musicBtn');
        const musicIndicator = document.getElementById('musicIndicator');
        let isMusicPlaying = false;
        let musicVolume = 0.5;
        
        // Sound Effects Elements
        const eatSound = document.getElementById('eatSound');
        let soundVolume = 0.7;
        
        // Invite System Variables
        let inviteData = {
            myInviteCode: '',
            invitedBy: '',
            invitedUsers: [],
            inviteBonus: 0,
            hasUsedInviteCode: false,
            isValidUser: false
        };
        
                // Game State Variables
        let playerId = null;
        let playerWallet = ''; // Player wallet address
        let playerName = 'Anonymous';
        let snake = [];
        let otherPlayers = {};
        let foods = []; // Changed to array to store multiple foods
        let specialFood = null;
        let corpseFoods = []; // Dead player's snake body becomes food
        let direction = '';
        let nextDirection = '';
        let score = 0;
        let level = 1;
        let gameSpeed = 100; // milliseconds, slightly faster to adapt to larger game area
        let gameLoop;
        let isGameRunning = false;
        let isPaused = false;
        let gameRoom = 'default'; // Game room
        let playerColor = '';
        let playerAvatar = '';
        let gameMargin = 0; // Game margin (border)
        const MAX_FOODS = 5; // Maximum number of foods on field
        
        // Firebase Functions Reference
        const claimTokenFunction = firebase.functions().httpsCallable('claimToken');
        
        // Image Resources
        let snakeHeadImage = null;
        let snakeBodyImage = null;
        let snakeTailImage = null;
                  let foodImage = null;
          let corpseImage = null;
          let snakeTurnEImage = null;  // Âè≥‰∏ãËΩ¨ÂºØ
          let snakeTurnQImage = null;  // Â∑¶‰∏ãËΩ¨ÂºØ
          let snakeTurnRImage = null;  // Â∑¶‰∏äËΩ¨ÂºØ
          let snakeTurnWImage = null;  // Âè≥‰∏äËΩ¨ÂºØ
          let imagesLoaded = 0;
          const totalImages = 9;
        
        // Meme elements
        const memeFaces = ['(‚óç‚Ä¢·¥ó‚Ä¢‚óç)', '(¬¨‚Äø¬¨)', '( ò‚Äø ò)', '(‚óî_‚óî)', '(¬∞„É≠¬∞)'];
        const memeColors = [
            '#FFE100', '#0066FF', '#FF3333', '#33CC33', '#FF66CC',
            '#FF9900', '#9966FF', '#66CCFF', '#FF6666', '#99FF66'
        ];
        
                         // Set Canvas Size
        function resizeCanvas() {
            const container = canvas.parentElement;
            // Use fixed canvas size to ensure all players see the same map
            canvas.width = 1200; // Fixed width 1200px
            canvas.height = 960; // Fixed height 960px, maintain 5:4 ratio
            
            // Calculate margin (border)
            const margin = Math.floor(canvas.width * 0.05); // 5% margin
            gameMargin = margin;
        }
        
        // Load image resources
        function loadImages() {
            snakeHeadImage = new Image();
            snakeBodyImage = new Image();
            snakeTailImage = new Image();
            foodImage = new Image();
            corpseImage = new Image();
            snakeTurnEImage = new Image();
            snakeTurnQImage = new Image();
            snakeTurnRImage = new Image();
            snakeTurnWImage = new Image();
            
            snakeHeadImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeBodyImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeTailImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            foodImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            corpseImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeTurnEImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeTurnQImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeTurnRImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeTurnWImage.onload = function() {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('All images loaded');
                }
            };
            
            snakeHeadImage.src = 'png/snake1.png';
            snakeBodyImage.src = 'png/snake.png';
            snakeTailImage.src = 'png/snake4.png';
            foodImage.src = 'png/snake2.png';
            corpseImage.src = 'png/snake3.png';
            snakeTurnEImage.src = 'png/e.png';     // Âè≥‰∏ãËΩ¨ÂºØ
            snakeTurnQImage.src = 'png/q.png';     // Â∑¶‰∏ãËΩ¨ÂºØ
            snakeTurnRImage.src = 'png/r.png';     // Â∑¶‰∏äËΩ¨ÂºØ
            snakeTurnWImage.src = 'png/w.png';     // Âè≥‰∏äËΩ¨ÂºØ
        }
        
        // Initialize canvas size and listen for window resize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Load images
        loadImages();
        
        // Generate unique player ID
        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substring(2, 10);
        }
        
        // Initialize Game
        function initGame() {
            // Get player wallet address and room
            if (playerNameInput.value.trim()) {
                playerWallet = playerNameInput.value.trim();
                playerName = playerWallet.substring(0, 8) + '...' + playerWallet.substring(playerWallet.length - 4);
            } else {
                alert('Please enter a valid wallet address!');
                return;
            }
            
            // Validate wallet address format (simple Solana address validation)
            if (!playerWallet.match(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)) {
                alert('Please enter a valid Solana wallet address!');
                return;
            }
            
            // Use wallet address as player ID
            playerId = playerWallet;
            gameRoom = roomSelect.value;
            playerNameElement.textContent = playerName;
            
            // Update room name display
            const roomNames = {
                'default': 'Default Room',
                'room1': 'Room 1 - Beginner',
                'room2': 'Room 2 - Advanced',
                'room3': 'Room 3 - Casual'
            };
            roomNameElement.textContent = roomNames[gameRoom] || 'Default Room';
            
                                     // Set initial snake position
            const gridSize = 15; // Fixed grid size
            
            // Calculate effective game area using fixed canvas size
            const canvasWidth = 1200;
            const canvasHeight = 960;
            const margin = Math.floor(canvasWidth * 0.05); // 60px margin
            const effectiveWidth = canvasWidth - 2 * margin;
            const effectiveHeight = canvasHeight - 2 * margin;
            const gridCols = Math.floor(effectiveWidth / gridSize);
            const gridRows = Math.floor(effectiveHeight / gridSize);
            
            // Define spawn points (using grid coordinates, within effective area)
            const spawnPoints = [
                {gridX: 5, gridY: 5},
                {gridX: gridCols - 5, gridY: 5},
                {gridX: 5, gridY: gridRows - 5},
                {gridX: gridCols - 5, gridY: gridRows - 5}
            ];
            const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            
            // Convert to pixel coordinates (add margin offset)
            const pixelX = margin + spawnPoint.gridX * gridSize;
            const pixelY = margin + spawnPoint.gridY * gridSize;
            
                                     snake = [
                { x: pixelX, y: pixelY },
                { x: pixelX - gridSize, y: pixelY },
                { x: pixelX - gridSize * 2, y: pixelY },
                { x: pixelX - gridSize * 3, y: pixelY }
            ];
            
            // Initial direction
            direction = 'right';
            nextDirection = 'right';
            
                         // Reset score and level
             score = 0;
             level = 1;
             gameSpeed = 100; // Slightly increase speed to adapt to larger game area
            
            // Update UI
            updateScore();
            
            // Save player info to Firebase
            savePlayerInfo();
            
            // Listen for other players and food
            listenForGameUpdates();
            
            // Initialize leaderboard display
            database.ref(`rooms/${gameRoom}/leaderboard`).once('value', (snapshot) => {
                const leaderboard = snapshot.val() || [];
                updateLeaderboardDisplay(leaderboard);
            });
            
            // Generate initial food (if doesn't exist)
            database.ref(`rooms/${gameRoom}/foods`).once('value', (snapshot) => {
                if (!snapshot.exists() || !snapshot.val() || snapshot.val().length === 0) {
                    generateInitialFoods();
                }
            });
            
            // Draw initial state immediately
            draw();
            
            // Set up a timer to keep drawing during countdown
            const drawInterval = setInterval(() => {
                if (isPaused && isGameRunning) {
                    // Keep drawing during countdown
                    draw();
                } else {
                    clearInterval(drawInterval);
                }
            }, 100); // Draw 10 times per second during countdown
        }
        
        // Save player info to Firebase
        function savePlayerInfo() {
            // Check room player limit before saving
            database.ref(`rooms/${gameRoom}/players`).once('value', (snapshot) => {
                const players = snapshot.val() || {};
                const currentPlayerCount = Object.keys(players).length;
                
                // Check if room is full (max 10 players)
                if (currentPlayerCount >= 10) {
                    alert('This room is full! Maximum 10 players allowed. Please try another room.');
                    // Reset game state
                    isGameRunning = false;
                    startScreen.classList.remove('hidden');
                    pauseBtn.classList.add('hidden');
                    roomSwitchBtn.classList.add('hidden');
                    return;
                }
                
                const playerRef = database.ref(`rooms/${gameRoom}/players/${playerId}`);
                
                // Set player initial info
                playerRef.set({
                    name: playerName,
                    wallet: playerWallet,
                    snake: snake,
                    direction: direction,
                    score: score,
                    alive: true,
                    color: playerColor || memeColors[Math.floor(Math.random() * memeColors.length)],
                    room: gameRoom,
                    lastActive: Date.now()
                });
                
                // Remove player when page closes
                window.addEventListener('beforeunload', () => {
                    playerRef.remove();
                });
                
                // Regularly update last active time
                setInterval(() => {
                    if (isGameRunning && !isPaused) {
                        playerRef.update({
                            lastActive: Date.now()
                        });
                    }
                }, 5000);
            });
        }
        
        // Listen for game updates
        function listenForGameUpdates() {
            // Listen for game state
            database.ref('gameState').on('value', (snapshot) => {
                if (snapshot.exists()) {
                    const gameState = snapshot.val();
                    handleGameStateChange(gameState);
                }
            });
            
            // Listen for other players
            database.ref(`rooms/${gameRoom}/players`).on('value', (snapshot) => {
                const players = snapshot.val() || {};
                otherPlayers = {};
                
                // Update player list
                playersListElement.innerHTML = '';
                playerCountElement.textContent = Object.keys(players).length;
                
                let activeCount = 0;
                Object.keys(players).forEach(id => {
                    if (id !== playerId && players[id].alive) {
                        otherPlayers[id] = players[id];
                        activeCount++;
                    }
                    
                    // Add to player list
                    const li = document.createElement('li');
                    li.className = id === playerId ? 'text-memeGreen font-bold' : '';
                    li.innerHTML = `<span style="color: ${players[id].color}">‚óè</span> ${players[id].name} (${players[id].score})`;
                    playersListElement.appendChild(li);
                });
                
                // Update statistics
                totalPlayersElement.textContent = Object.keys(players).length;
                activePlayersElement.textContent = activeCount + (isGameRunning ? 1 : 0);
            });
            
            // Listen for food
            database.ref(`rooms/${gameRoom}/foods`).on('value', (snapshot) => {
                if (snapshot.exists()) {
                    foods = snapshot.val() || [];
                } else {
                    foods = [];
                }
            });
            
            // Listen for special food
            database.ref(`rooms/${gameRoom}/specialFood`).on('value', (snapshot) => {
                if (snapshot.exists()) {
                    specialFood = snapshot.val();
                } else {
                    specialFood = null;
                }
            });
            
            // Listen for corpse food
            database.ref(`rooms/${gameRoom}/corpseFoods`).on('value', (snapshot) => {
                if (snapshot.exists()) {
                    corpseFoods = snapshot.val() || [];
                } else {
                    corpseFoods = [];
                }
            });
            
            // Listen for room leaderboard
            database.ref(`rooms/${gameRoom}/leaderboard`).on('value', (snapshot) => {
                const leaderboard = snapshot.val() || [];
                let maxScore = 0;
                
                if (leaderboard.length > 0) {
                    maxScore = leaderboard[0].score || 0;
                }
                
                roomHighScoreElement.textContent = maxScore;
                
                // Update leaderboard display
                updateLeaderboardDisplay(leaderboard);
            });
        }
        
        // Handle game state changes
        function handleGameStateChange(gameState) {
            if (!gameState.isRunning && isGameRunning) {
                // Game was paused
                pauseGame();
                showGamePausedMessage();
            } else if (gameState.isRunning && !isGameRunning) {
                // Game resumed
                resumeGame();
                hideGamePausedMessage();
            }
            
            // Update countdown display
            updateCountdown(gameState.nextReset);
        }
        
        // Show game paused message
        function showGamePausedMessage() {
            const message = document.createElement('div');
            message.id = 'gamePausedMessage';
            message.className = 'absolute inset-0 bg-gray-900/90 flex items-center justify-center z-20';
            message.innerHTML = `
                <div class="text-center">
                    <h2 class="text-3xl font-bold text-yellow-400 mb-4">Game Paused</h2>
                    <p class="text-xl text-white">Waiting for admin to resume game...</p>
                </div>
            `;
            canvas.parentElement.appendChild(message);
        }
        
        // Hide game paused message
        function hideGamePausedMessage() {
            const message = document.getElementById('gamePausedMessage');
            if (message) {
                message.remove();
            }
        }
        
        // Update countdown display
        function updateCountdown(nextReset) {
            if (!nextReset) return;
            
            const timeLeft = Math.max(0, nextReset - Date.now());
            const minutes = Math.floor(timeLeft / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);
            
            // Update countdown display
            const countdownEl = document.getElementById('countdown');
            if (countdownEl) {
                countdownEl.textContent = `Next Reset: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Show warning when time is less than 5 minutes
                if (timeLeft < 300000) {
                    countdownEl.className = 'text-red-400 font-bold';
                } else if (timeLeft < 600000) {
                    countdownEl.className = 'text-yellow-400 font-bold';
                } else {
                    countdownEl.className = 'text-white';
                }
            }
            
            // Check if leaderboard needs to be reset (when countdown ends)
            if (timeLeft <= 0) {
                // Can add leaderboard reset logic here
                // Currently leaderboard persists unless admin manually resets
            }
        }
        
        // Pause game
        function pauseGame() {
            isGameRunning = false;
            if (gameLoop) {
                clearInterval(gameLoop);
                gameLoop = null;
            }
        }
        
        // Resume game
        function resumeGame() {
            if (!isGameRunning) {
                isGameRunning = true;
                startGameLoop();
            }
        }
        
        // Start game loop
        function startGameLoop() {
            if (gameLoop) {
                clearInterval(gameLoop);
            }
            gameLoop = setInterval(gameUpdate, gameSpeed);
        }
        
        // Update leaderboard display
        function updateLeaderboardDisplay(leaderboard) {
            leaderboardElement.innerHTML = '';
            
            leaderboard.forEach((entry, index) => {
                const li = document.createElement('li');
                li.className = index === 0 ? 'text-memeYellow font-bold' : 
                              index === 1 ? 'text-gray-300' : 
                              index === 2 ? 'text-amber-700' : '';
                
                // Format time (UTC)
                const date = new Date(entry.timestamp);
                const timeStr = `${date.getUTCMonth() + 1}/${date.getUTCDate()} ${date.getUTCHours()}:${date.getUTCMinutes().toString().padStart(2, '0')} UTC`;
                
                li.innerHTML = `${index + 1}. ${entry.playerName} - ${entry.score} pts <span class="text-xs text-gray-500">(${timeStr})</span>`;
                leaderboardElement.appendChild(li);
            });
        }
        
        // Update current player leaderboard (for real-time display)
        function updateLeaderboard(players) {
            // This function is now mainly used for real-time display of current online player scores
            // No longer used for persistent leaderboard
        }
        

        
        // Generate initial food (generate multiple foods)
        function generateInitialFoods() {
            const gridSize = 15; // Fixed grid size
            const foodsToGenerate = Math.min(MAX_FOODS, 3); // Initially generate 3 foods
            
            database.ref(`rooms/${gameRoom}/players`).once('value', (snapshot) => {
                const players = snapshot.val() || {};
                const newFoods = [];
                
                for (let i = 0; i < foodsToGenerate; i++) {
                    const newFood = generateSingleFood(players, newFoods);
                    if (newFood) {
                        newFoods.push(newFood);
                    }
                }
                
                // Save all foods to Firebase
                database.ref(`rooms/${gameRoom}/foods`).set(newFoods);
            });
        }
        
        // Generate single food
        function generateSingleFood(players, existingFoods = []) {
            // Use fixed grid dimensions to ensure all players see the same map
            const gridSize = 15; // Fixed grid size
            let attempts = 0;
            const maxAttempts = 100;
            
            while (attempts < maxAttempts) {
                attempts++;
                // Use fixed canvas dimensions to calculate effective game area
                const canvasWidth = 1200;
                const canvasHeight = 960;
                const margin = Math.floor(canvasWidth * 0.05); // 60px margin
                const effectiveWidth = canvasWidth - 2 * margin;
                const effectiveHeight = canvasHeight - 2 * margin;
                const gridCols = Math.floor(effectiveWidth / gridSize);
                const gridRows = Math.floor(effectiveHeight / gridSize);
                
                // Generate random grid coordinates (within effective area)
                const gridX = Math.floor(Math.random() * gridCols);
                const gridY = Math.floor(Math.random() * gridRows);
                
                // Convert to pixel coordinates (add margin offset)
                const pixelX = margin + gridX * gridSize;
                const pixelY = margin + gridY * gridSize;
                
                const newFood = {
                    x: pixelX,
                    y: pixelY,
                    color: memeColors[Math.floor(Math.random() * memeColors.length)],
                    meme: memeFaces[Math.floor(Math.random() * memeFaces.length)],
                    timestamp: Date.now(),
                    id: 'food_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9)
                };
                
                let validPosition = true;
                
                // Check if overlaps with current player snake body
                for (let segment of snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        validPosition = false;
                        break;
                    }
                }
                
                if (!validPosition) continue;
                
                // Check if overlaps with other player snake bodies
                Object.values(players).forEach(player => {
                    if (player.snake && player.alive) {
                        for (let segment of player.snake) {
                            if (segment.x === newFood.x && segment.y === newFood.y) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                    if (!validPosition) return;
                });
                
                // Check if overlaps with existing foods
                existingFoods.forEach(food => {
                    if (food.x === newFood.x && food.y === newFood.y) {
                        validPosition = false;
                    }
                });
                
                // Check if overlaps with corpse foods
                if (corpseFoods && corpseFoods.length > 0) {
                    corpseFoods.forEach(corpseFood => {
                        if (corpseFood.x === newFood.x && corpseFood.y === newFood.y) {
                            validPosition = false;
                        }
                    });
                }
                
                if (validPosition) {
                    return newFood;
                }
            }
            
            // If no valid position found, return null
            return null;
        }
        
                // Generate normal food (called when food is eaten)
        function generateFood() {
            const gridSize = 15; // Fixed grid size
            
            // Ensure food doesn't appear on any snake body
            database.ref(`rooms/${gameRoom}/players`).once('value', (snapshot) => {
                const players = snapshot.val() || {};
                
                // Get current food list
                database.ref(`rooms/${gameRoom}/foods`).once('value', (foodsSnapshot) => {
                    const currentFoods = foodsSnapshot.val() || [];
                    
                    // If current food count is less than maximum, generate new food
                    if (currentFoods.length < MAX_FOODS) {
                        const newFood = generateSingleFood(players, currentFoods);
                        if (newFood) {
                            currentFoods.push(newFood);
                            database.ref(`rooms/${gameRoom}/foods`).set(currentFoods);
                        }
                    }
                });
            });
        }
        
        // Generate special food
        function generateSpecialFood() {
            // Use fixed grid dimensions to ensure all players see the same map
            const gridSize = 15; // Fixed grid size
            let newFood;
            
            // Ensure special food doesn't appear on any snake body or normal food position
            database.ref(`rooms/${gameRoom}/players`).once('value', (playersSnapshot) => {
                database.ref(`rooms/${gameRoom}/foods`).once('value', (foodsSnapshot) => {
                    const players = playersSnapshot.val() || {};
                    const currentFoods = foodsSnapshot.val() || [];
                    let validPosition = false;
                    
                    while (!validPosition) {
                        // Use fixed canvas dimensions to calculate effective game area
                        const canvasWidth = 1200;
                        const canvasHeight = 960;
                        const margin = Math.floor(canvasWidth * 0.05); // 60px margin
                        const effectiveWidth = canvasWidth - 2 * margin;
                        const effectiveHeight = canvasHeight - 2 * margin;
                        const gridCols = Math.floor(effectiveWidth / gridSize);
                        const gridRows = Math.floor(effectiveHeight / gridSize);
                        
                        // Generate random grid coordinates (within effective area)
                        const gridX = Math.floor(Math.random() * gridCols);
                        const gridY = Math.floor(Math.random() * gridRows);
                        
                        // Convert to pixel coordinates (add margin offset)
                        const pixelX = margin + gridX * gridSize;
                        const pixelY = margin + gridY * gridSize;
                        
                        newFood = {
                            x: pixelX,
                            y: pixelY,
                            color: '#FFFFFF',
                            meme: '‚ú®',
                            timestamp: Date.now(),
                            timer: 50 // Exists for 50 game frames
                        };
                        
                        validPosition = true;
                        
                        // Check if overlaps with normal food
                        currentFoods.forEach(food => {
                            if (food.x === newFood.x && food.y === newFood.y) {
                                validPosition = false;
                            }
                        });
                        
                        if (!validPosition) continue;
                        
                        // Check if overlaps with corpse food
                        if (corpseFoods && corpseFoods.length > 0) {
                            corpseFoods.forEach(corpseFood => {
                                if (corpseFood.x === newFood.x && corpseFood.y === newFood.y) {
                                    validPosition = false;
                                }
                            });
                        }
                        
                        if (!validPosition) continue;
                        
                        // Check if overlaps with current player snake body
                        for (let segment of snake) {
                            if (segment.x === newFood.x && segment.y === newFood.y) {
                                validPosition = false;
                                break;
                            }
                        }
                        
                        if (!validPosition) continue;
                        
                        // Check if overlaps with other player snake bodies
                        Object.values(players).forEach(player => {
                            if (player.snake && player.alive) {
                                for (let segment of player.snake) {
                                    if (segment.x === newFood.x && segment.y === newFood.y) {
                                        validPosition = false;
                                        break;
                                    }
                                }
                            }
                            if (!validPosition) return;
                        });
                    }
                    
                    // Save special food to Firebase
                    database.ref(`rooms/${gameRoom}/specialFood`).set(newFood);
                    
                    // Remove special food after 5 seconds
                    setTimeout(() => {
                        database.ref(`rooms/${gameRoom}/specialFood`).once('value', (snapshot) => {
                            if (snapshot.exists() && snapshot.val().timestamp === newFood.timestamp) {
                                database.ref(`rooms/${gameRoom}/specialFood`).remove();
                            }
                        });
                    }, 5000);
                });
            });
        }
        
                // Update score
        function updateScore() {
            scoreElement.textContent = score;
            finalScoreElement.textContent = score;
            
            // Update score in Firebase
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).update({
                    score: score
                });
            }
        }
        
        // Update total user score (called when game ends)
        function updateTotalUserScore() {
            if (playerWallet && score > 0) {
                database.ref(`users/${playerWallet}`).once('value', (snapshot) => {
                    const userData = snapshot.val() || {};
                    const currentTotalScore = userData.score || 0;
                    const newTotalScore = currentTotalScore + score;
                    
                    database.ref(`users/${playerWallet}`).update({
                        score: newTotalScore,
                        lastUpdated: Date.now()
                    });
                });
            }
        }
        
        // Check collision
        function checkCollision() {
            const head = snake[0];
            const gridSize = 15; // Fixed grid size
            
            // Check wall collision (considering margin)
            if (head.x < gameMargin || head.x >= canvas.width - gameMargin || 
                head.y < gameMargin || head.y >= canvas.height - gameMargin) {
                return true;
            }
            
            // Check self collision
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            
            // Check collision with other players (including dead player snake bodies)
            Object.values(otherPlayers).forEach(player => {
                if (player.snake) {
                    for (let segment of player.snake) {
                        if (head.x === segment.x && head.y === segment.y) {
                            return true;
                        }
                    }
                }
            });
            
            return false;
        }
        
        // Check food collision
        function checkFoodCollision() {
            const head = snake[0];
            const gridSize = 15; // Fixed grid size
            let ateFood = false;
            
            // Check normal food collision
            if (foods && foods.length > 0) {
                for (let i = 0; i < foods.length; i++) {
                    const food = foods[i];
                    
                    // Debug info: show snake head and food coordinates
                    console.log('Collision detection:', {
                        head: {x: head.x, y: head.y},
                        food: {x: food.x, y: food.y},
                        gridSize: gridSize,
                        distance: Math.sqrt(Math.pow(head.x - food.x, 2) + Math.pow(head.y - food.y, 2))
                    });
                    
                    // Use more lenient collision detection
                    if (Math.abs(head.x - food.x) < gridSize/2 && Math.abs(head.y - food.y) < gridSize/2) {
                        console.log('Ate normal food!', {head, food}); // Debug info
                        
                        // Calculate base score and bonus
                        let baseScore = 10;
                        let bonusScore = Math.floor(baseScore * (inviteData.inviteBonus || 0) / 100);
                        let totalScore = baseScore + bonusScore;
                        
                        // Increase score
                        score += totalScore;
                        
                        // Level up every 100 points
                        if (score % 100 === 0) {
                            level++;
                            // Speed up game, minimum 50ms
                            gameSpeed = Math.max(50, gameSpeed - 10);
                            // Reset game loop speed
                            if (isGameRunning && !isPaused) {
                                clearInterval(gameLoop);
                                gameLoop = setInterval(gameUpdate, gameSpeed);
                            }
                        }
                        
                        updateScore();
                        
                        // Remove eaten food
                        const updatedFoods = foods.filter((_, index) => index !== i);
                        database.ref(`rooms/${gameRoom}/foods`).set(updatedFoods);
                        
                        // Play eat sound effect
                        playEatSound();
                        
                        // Generate new food
                        generateFood();
                        
                        // 10% chance to generate special food
                        if (Math.random() < 0.1) {
                            generateSpecialFood();
                        }
                        
                        ateFood = true;
                        break; // Can only eat one food at a time
                    }
                }
            }
            
            // Check corpse food collision
            if (corpseFoods && corpseFoods.length > 0) {
                for (let i = 0; i < corpseFoods.length; i++) {
                    const corpseFood = corpseFoods[i];
                    
                    // Use more lenient collision detection
                    if (Math.abs(head.x - corpseFood.x) < gridSize/2 && Math.abs(head.y - corpseFood.y) < gridSize/2) {
                        console.log('Ate corpse food!', {head, corpseFood}); // Debug info
                        
                        // Play eat sound effect
                        playEatSound();
                        
                        // Calculate corpse food score and bonus
                        let baseScore = 5;
                        let bonusScore = Math.floor(baseScore * (inviteData.inviteBonus || 0) / 100);
                        let totalScore = baseScore + bonusScore;
                        
                        // Corpse food only adds score, doesn't increase snake length
                        score += totalScore;
                        updateScore();
                        
                        // Remove eaten corpse food
                        const updatedCorpseFoods = corpseFoods.filter((_, index) => index !== i);
                        database.ref(`rooms/${gameRoom}/corpseFoods`).set(updatedCorpseFoods);
                        
                        // Note: Don't eat corpse food, so don't set ateFood = true
                        break; // Can only eat one food at a time
                    }
                }
            }
            
            // Special food - use more lenient collision detection
            if (specialFood && Math.abs(head.x - specialFood.x) < gridSize/2 && Math.abs(head.y - specialFood.y) < gridSize/2) {
                console.log('Ate special food!', {head, specialFood}); // Debug info
                
                // Play eat sound effect
                playEatSound();
                
                // Calculate special food score and bonus
                let baseScore = 50;
                let bonusScore = Math.floor(baseScore * (inviteData.inviteBonus || 0) / 100);
                let totalScore = baseScore + bonusScore;
                
                // Special food gives more score
                score += totalScore;
                updateScore();
                database.ref(`rooms/${gameRoom}/specialFood`).remove();
                ateFood = true;
            }
            
            return ateFood;
        }
        
                // Update game state
        function gameUpdate() {
            if (isPaused || !isGameRunning) return;
            
            // Update direction
            direction = nextDirection;
            
            const gridSize = 15; // Fixed grid size
            const head = { x: snake[0].x, y: snake[0].y };
            
            // Move snake head according to direction
            switch (direction) {
                case 'up':
                    head.y -= gridSize;
                    break;
                case 'down':
                    head.y += gridSize;
                    break;
                case 'left':
                    head.x -= gridSize;
                    break;
                case 'right':
                    head.x += gridSize;
                    break;
            }
            
            // Add new head to snake
            snake.unshift(head);
            
            // Check if food was eaten
            const ateFood = checkFoodCollision();
            
            // If no food was eaten, remove tail
            if (!ateFood) {
                snake.pop();
            }
            
            // Check collision
            if (checkCollision()) {
                gameOver();
                return;
            }
            
            // Update snake state in Firebase
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).update({
                    snake: snake,
                    direction: direction
                });
            }
            
            // Draw game
            draw();
        }
        
        // Draw game
        function draw() {
            const gridSize = 15; // Fixed grid size
            
            // Clear canvas
            ctx.fillStyle = '#121212';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw background image
            const bgImage = new Image();
            bgImage.onload = function() {
                // Draw background image to cover the entire canvas
                ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
                
                // Continue with the rest of the drawing after background is loaded
                drawGameElements();
            };
            bgImage.onerror = function() {
                // If image fails to load, continue without background
                console.log('Background image failed to load, using default background');
                drawGameElements();
            };
            bgImage.src = '1.jpg';
            
            // Draw game elements function
            function drawGameElements() {
                // Draw margin area (border)
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, gameMargin); // Top margin
                ctx.fillRect(0, canvas.height - gameMargin, canvas.width, gameMargin); // Bottom margin
                ctx.fillRect(0, 0, gameMargin, canvas.height); // Left margin
                ctx.fillRect(canvas.width - gameMargin, 0, gameMargin, canvas.height); // Right margin
                
                // Draw grid background (only in effective game area)
                // ctx.strokeStyle = '#333333';
                // ctx.lineWidth = 1;
                
                // Only draw grid in effective game area
                // for (let x = gameMargin; x < canvas.width - gameMargin; x += gridSize) {
                //     ctx.beginPath();
                //     ctx.moveTo(x, gameMargin);
                //     ctx.lineTo(x, canvas.height - gameMargin);
                //     ctx.stroke();
                // }
                
                // for (let y = gameMargin; y < canvas.height - gameMargin; y += gridSize) {
                //     ctx.beginPath();
                //     ctx.moveTo(gameMargin, y);
                //     ctx.lineTo(canvas.width - gameMargin, y);
                //     ctx.stroke();
                // }
                
                // Draw other players' snakes
                Object.values(otherPlayers).forEach(player => {
                    if (player.snake) {
                        player.snake.forEach((segment, index) => {
                            // Snake head (simplified display)
                            if (index === 0) {
                                
                                // Draw snake head image (square)
                                if (snakeHeadImage && snakeHeadImage.complete) {
                                    ctx.save();
                                    ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                    
                                    // Rotate image according to direction
                                    let rotation = 0;
                                    switch (player.direction || 'right') {
                                        case 'up': rotation = -Math.PI / 2; break;
                                        case 'down': rotation = Math.PI / 2; break;
                                        case 'left': rotation = Math.PI; break;
                                        case 'right': rotation = 0; break;
                                    }
                                    ctx.rotate(rotation);
                                    
                                    // Add horizontal flip to fix upside-down issue
                                    ctx.scale(1, -1);
                                    ctx.drawImage(snakeHeadImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                    ctx.restore();
                                } else {
                                    // If image not loaded, use default emoji
                                    ctx.fillStyle = 'white';
                                    ctx.font = `${gridSize * 0.7}px "Comic Sans MS", cursive`;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText('üòú', segment.x + gridSize / 2, segment.y + gridSize / 2);
                                }
                                
                                // Player name label
                                ctx.fillStyle = player.color;
                                ctx.font = `${gridSize * 0.4}px "Comic Sans MS", cursive`;
                                ctx.fillText(player.name, segment.x + gridSize / 2, segment.y - 10);
                            } else if (index === player.snake.length - 1) {
                                // Snake tail (last position)
                                if (snakeTailImage && snakeTailImage.complete) {
                                    ctx.save();
                                    ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                    
                                    // Calculate tail direction (based on second-to-last position)
                                    let tailDirection = 'right';
                                    if (player.snake.length > 1) {
                                        const secondLast = player.snake[player.snake.length - 2];
                                        const last = player.snake[player.snake.length - 1];
                                        
                                        if (last.x > secondLast.x) tailDirection = 'right';
                                        else if (last.x < secondLast.x) tailDirection = 'left';
                                        else if (last.y > secondLast.y) tailDirection = 'down';
                                        else if (last.y < secondLast.y) tailDirection = 'up';
                                    }
                                    
                                    // Rotate image according to direction (correct tail root direction)
                                    let rotation = 0;
                                    switch (tailDirection) {
                                        case 'up': rotation = -Math.PI / 2; break;   // Up: -90 degrees
                                        case 'down': rotation = Math.PI / 2; break;  // Down: 90 degrees
                                        case 'left': rotation = Math.PI; break;      // Left: 180 degrees
                                        case 'right': rotation = 0; break;           // Right: 0 degrees
                                    }
                                    ctx.rotate(rotation);
                                    
                                    // Create circular clipping area
                                    ctx.beginPath();
                                    ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                                    ctx.clip();
                                    
                                    ctx.drawImage(snakeTailImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                    ctx.restore();
                                } else {
                                    // If image not loaded, use default circle
                                    ctx.fillStyle = player.color;
                                    ctx.beginPath();
                                    ctx.arc(segment.x + gridSize/2, segment.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            } else {
                                // Snake body
                                if (snakeBodyImage && snakeBodyImage.complete) {
                                    // Calculate body direction (based on front and back positions)
                                    let bodyDirection = 'right';
                                    let isCorner = false;
                                    
                                    if (index > 0 && index < player.snake.length - 1) {
                                        const prev = player.snake[index - 1];
                                        const next = player.snake[index + 1];
                                        
                                        // Check if it's a corner point (front and back positions form right angle)
                                        isCorner = (prev.x !== next.x) && (prev.y !== next.y);
                                        
                                        if (isCorner) {
                                            // Corner point: determine direction based on current segment's relative position to previous segment
                                            const current = player.snake[index];
                                            if (current.x > prev.x) bodyDirection = 'right';
                                            else if (current.x < prev.x) bodyDirection = 'left';
                                            else if (current.y > prev.y) bodyDirection = 'down';
                                            else if (current.y < prev.y) bodyDirection = 'up';
                                        } else {
                                            // Straight segment: use front and back positions to calculate direction
                                            if (next.x > prev.x) bodyDirection = 'right';
                                            else if (next.x < prev.x) bodyDirection = 'left';
                                            else if (next.y > prev.y) bodyDirection = 'down';
                                            else if (next.y < prev.y) bodyDirection = 'up';
                                        }
                                    } else if (index === 0) {
                                        // First segment after head, use head direction
                                        bodyDirection = player.direction || 'right';
                                    } else {
                                        // Last segment before tail, use tail direction
                                        const secondLast = player.snake[player.snake.length - 2];
                                        const last = player.snake[player.snake.length - 1];
                                        
                                        if (last.x > secondLast.x) bodyDirection = 'right';
                                        else if (last.x < secondLast.x) bodyDirection = 'left';
                                        else if (last.y > secondLast.y) bodyDirection = 'down';
                                        else if (last.y < secondLast.y) bodyDirection = 'up';
                                    }
                                    
                                    if (isCorner) {
                                        // Corner point: use dedicated corner image
                                        const prev = player.snake[index - 1];
                                        const next = player.snake[index + 1];
                                        const current = segment;
                                        
                                        // Calculate turn direction
                                        const fromDirection = {
                                            x: current.x - prev.x,
                                            y: current.y - prev.y
                                        };
                                        const toDirection = {
                                            x: next.x - current.x,
                                            y: next.y - current.y
                                        };
                                        
                                        let turnImage = null;
                                        let rotation = 0;
                                        
                                        // Determine turn type and select corresponding image
                                        if ((fromDirection.x === -15 && toDirection.y === 15) || (fromDirection.y === -15 && toDirection.x === 15)) {
                                            // Bottom-right turn: from left to down or from up to right
                                            turnImage = snakeTurnEImage;
                                            rotation = 0;
                                        } else if ((fromDirection.x === 15 && toDirection.y === 15) || (fromDirection.y === -15 && toDirection.x === -15)) {
                                            // Bottom-left turn: from right to down or from up to left
                                            turnImage = snakeTurnQImage;
                                            rotation = 0;
                                        } else if ((fromDirection.x === 15 && toDirection.y === -15) || (fromDirection.y === 15 && toDirection.x === -15)) {
                                            // Top-left turn: from right to up or from down to left
                                            turnImage = snakeTurnRImage;
                                            rotation = 0;
                                        } else if ((fromDirection.x === -15 && toDirection.y === -15) || (fromDirection.y === 15 && toDirection.x === 15)) {
                                            // Top-right turn: from left to up or from down to right
                                            turnImage = snakeTurnWImage;
                                            rotation = 0;
                                        }
                                        
                                        if (turnImage && turnImage.complete) {
                                            ctx.save();
                                            ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                            ctx.rotate(rotation);
                                            ctx.drawImage(turnImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                            ctx.restore();
                                        } else {
                                            // Corner image not loaded, use normal snake body image
                                            ctx.save();
                                            ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                            ctx.drawImage(snakeBodyImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                            ctx.restore();
                                        }
                                    } else {
                                        // Straight segment: use normal snake body image
                                        let rotation = 0;
                                        switch (bodyDirection) {
                                            case 'up': rotation = -Math.PI / 2; break;
                                            case 'down': rotation = Math.PI / 2; break;
                                            case 'left': rotation = Math.PI; break;
                                            case 'right': rotation = 0; break;
                                        }
                                        
                                        ctx.save();
                                        ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                        ctx.rotate(rotation);
                                        ctx.drawImage(snakeBodyImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                        ctx.restore();
                                    }
                                } else {
                                    // If image not loaded, use default circle
                                    ctx.fillStyle = player.color;
                                    ctx.beginPath();
                                    ctx.arc(segment.x + gridSize/2, segment.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                        });
                    }
                });
                
                // Draw own snake
                snake.forEach((segment, index) => {
                    // Snake head (simplified display)
                    if (index === 0) {
                        
                        // Draw snake head image (square)
                        if (snakeHeadImage && snakeHeadImage.complete) {
                            ctx.save();
                            ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                            
                            // Rotate image according to direction
                            let rotation = 0;
                            switch (direction) {
                                case 'up': rotation = -Math.PI / 2; break;
                                case 'down': rotation = Math.PI / 2; break;
                                case 'left': rotation = Math.PI; break;
                                case 'right': rotation = 0; break;
                            }
                            ctx.rotate(rotation);
                            
                            // Add horizontal flip to fix upside-down issue
                            ctx.scale(1, -1);
                            ctx.drawImage(snakeHeadImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                            ctx.restore();
                        } else {
                            // If image not loaded, use default emoji
                            ctx.fillStyle = 'white';
                            ctx.font = `${gridSize * 0.7}px "Comic Sans MS", cursive`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('üòõ', segment.x + gridSize / 2, segment.y + gridSize / 2);
                        }
                        
                        // Own name label
                        ctx.fillStyle = '#FF3333';
                        ctx.font = `${gridSize * 0.4}px "Comic Sans MS", cursive`;
                        ctx.fillText(playerName, segment.x + gridSize / 2, segment.y - 10);
                    } else if (index === snake.length - 1) {
                        // Snake tail (last position)
                        if (snakeTailImage && snakeTailImage.complete) {
                            ctx.save();
                            ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                            
                            // Calculate tail direction (based on second-to-last position)
                            let tailDirection = 'right';
                            if (snake.length > 1) {
                                const secondLast = snake[snake.length - 2];
                                const last = snake[snake.length - 1];
                                
                                if (last.x > secondLast.x) tailDirection = 'right';
                                else if (last.x < secondLast.x) tailDirection = 'left';
                                else if (last.y > secondLast.y) tailDirection = 'down';
                                else if (last.y < secondLast.y) tailDirection = 'up';
                            }
                            
                            // Rotate image according to direction (correct tail root direction)
                            let rotation = 0;
                            switch (tailDirection) {
                                case 'up': rotation = -Math.PI / 2; break;   // Up: -90 degrees
                                case 'down': rotation = Math.PI / 2; break;  // Down: 90 degrees
                                case 'left': rotation = Math.PI; break;      // Left: 180 degrees
                                case 'right': rotation = 0; break;           // Right: 0 degrees
                            }
                            ctx.rotate(rotation);
                            
                            // Create circular clipping area
                            ctx.beginPath();
                            ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                            ctx.clip();
                            
                            ctx.drawImage(snakeTailImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                            ctx.restore();
                        } else {
                            // If image not loaded, use default circle
                            const colorIndex = (index % memeColors.length);
                            ctx.fillStyle = memeColors[colorIndex];
                            ctx.beginPath();
                            ctx.arc(segment.x + gridSize/2, segment.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else {
                        // Snake body
                        if (snakeBodyImage && snakeBodyImage.complete) {
                            // Calculate body direction (based on front and back positions)
                            let bodyDirection = 'right';
                            let isCorner = false;
                            
                            if (index > 0 && index < snake.length - 1) {
                                const prev = snake[index - 1];
                                const next = snake[index + 1];
                                
                                // Check if it's a corner point (front and back positions form right angle)
                                isCorner = (prev.x !== next.x) && (prev.y !== next.y);
                                
                                if (isCorner) {
                                    // Corner point: determine direction based on current segment's relative position to previous segment
                                    const current = snake[index];
                                    if (current.x > prev.x) bodyDirection = 'right';
                                    else if (current.x < prev.x) bodyDirection = 'left';
                                    else if (current.y > prev.y) bodyDirection = 'down';
                                    else if (current.y < prev.y) bodyDirection = 'up';
                                } else {
                                    // Straight segment: use front and back positions to calculate direction
                                    if (next.x > prev.x) bodyDirection = 'right';
                                    else if (next.x < prev.x) bodyDirection = 'left';
                                    else if (next.y > prev.y) bodyDirection = 'down';
                                    else if (next.y < prev.y) bodyDirection = 'up';
                                }
                            } else if (index === 0) {
                                // First segment after head, use head direction
                                bodyDirection = direction;
                            } else {
                                // Last segment before tail, use tail direction
                                const secondLast = snake[snake.length - 2];
                                const last = snake[snake.length - 1];
                                
                                if (last.x > secondLast.x) bodyDirection = 'right';
                                else if (last.x < secondLast.x) bodyDirection = 'left';
                                else if (last.y > secondLast.y) bodyDirection = 'down';
                                else if (last.y < secondLast.y) bodyDirection = 'up';
                            }
                            
                            if (isCorner) {
                                // Corner point: use dedicated corner image
                                const prev = snake[index - 1];
                                const next = snake[index + 1];
                                const current = segment;
                                
                                // Calculate turn direction
                                const fromDirection = {
                                    x: current.x - prev.x,
                                    y: current.y - prev.y
                                };
                                const toDirection = {
                                    x: next.x - current.x,
                                    y: next.y - current.y
                                };
                                
                                let turnImage = null;
                                let rotation = 0;
                                
                                // Determine turn type and select corresponding image
                                if ((fromDirection.x === -15 && toDirection.y === 15) || (fromDirection.y === -15 && toDirection.x === 15)) {
                                    // Bottom-right turn: from left to down or from up to right
                                    turnImage = snakeTurnEImage;
                                    rotation = 0;
                                } else if ((fromDirection.x === 15 && toDirection.y === 15) || (fromDirection.y === -15 && toDirection.x === -15)) {
                                    // Bottom-left turn: from right to down or from up to left
                                    turnImage = snakeTurnQImage;
                                    rotation = 0;
                                } else if ((fromDirection.x === 15 && toDirection.y === -15) || (fromDirection.y === 15 && toDirection.x === -15)) {
                                    // Top-left turn: from right to up or from down to left
                                    turnImage = snakeTurnRImage;
                                    rotation = 0;
                                } else if ((fromDirection.x === -15 && toDirection.y === -15) || (fromDirection.y === 15 && toDirection.x === 15)) {
                                    // Top-right turn: from left to up or from down to right
                                    turnImage = snakeTurnWImage;
                                    rotation = 0;
                                }
                                
                                if (turnImage && turnImage.complete) {
                                    ctx.save();
                                    ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                    ctx.rotate(rotation);
                                    ctx.drawImage(turnImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                    ctx.restore();
                                } else {
                                    // Corner image not loaded, use normal snake body image
                                    ctx.save();
                                    ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                    ctx.drawImage(snakeBodyImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                    ctx.restore();
                                }
                            } else {
                                // Straight segment: use normal snake body image
                                let rotation = 0;
                                switch (bodyDirection) {
                                    case 'up': rotation = -Math.PI / 2; break;
                                    case 'down': rotation = Math.PI / 2; break;
                                    case 'left': rotation = Math.PI; break;
                                    case 'right': rotation = 0; break;
                                }
                                
                                ctx.save();
                                ctx.translate(segment.x + gridSize / 2, segment.y + gridSize / 2);
                                ctx.rotate(rotation);
                                ctx.drawImage(snakeBodyImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                                ctx.restore();
                            }
                        } else {
                            // If image not loaded, use default circle
                            const colorIndex = (index % memeColors.length);
                            ctx.fillStyle = memeColors[colorIndex];
                            ctx.beginPath();
                            ctx.arc(segment.x + gridSize/2, segment.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
                
                // Draw normal food
                if (foods && foods.length > 0) {
                    foods.forEach(food => {
                        ctx.fillStyle = food.color;
                        ctx.shadowColor = food.color;
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(food.x + gridSize / 2, food.y + gridSize / 2, gridSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Draw food image
                        if (foodImage && foodImage.complete) {
                            ctx.save();
                            ctx.translate(food.x + gridSize / 2, food.y + gridSize / 2);
                            
                            // Create circular clipping area
                            ctx.beginPath();
                            ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                            ctx.clip();
                            
                            ctx.drawImage(foodImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                            ctx.restore();
                        } else {
                            // If image not loaded, use default emoji
                            ctx.fillStyle = 'black';
                            ctx.font = `${gridSize * 0.5}px "Comic Sans MS", cursive`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(food.meme, food.x + gridSize / 2, food.y + gridSize / 2);
                        }
                    });
                }
                
                // Draw corpse food
                if (corpseFoods && corpseFoods.length > 0) {
                    corpseFoods.forEach(corpseFood => {
                        // Save current context
                        ctx.save();
                        
                        // Calculate animation effects
                        const time = Date.now() / 1000;
                        const pulseScale = 1 + Math.sin(time * (corpseFood.pulse || 2)) * 0.1;
                        const wiggleOffset = Math.sin(time * 3) * (corpseFood.wiggle || 3);
                        const rotation = (corpseFood.rotation || 0) + Math.sin(time * 2) * 10;
                        
                        // Set transformations
                        ctx.translate(corpseFood.x + gridSize / 2 + wiggleOffset, corpseFood.y + gridSize / 2);
                        ctx.rotate(rotation * Math.PI / 180);
                        ctx.scale(pulseScale, pulseScale);
                        
                        // Draw glowing background
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, gridSize / 2);
                        gradient.addColorStop(0, corpseFood.color);
                        gradient.addColorStop(0.7, corpseFood.color + '80');
                        gradient.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = gradient;
                        ctx.shadowColor = corpseFood.color;
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw border
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, gridSize / 2 - 2, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Reset shadow
                        ctx.shadowBlur = 0;
                        
                        // Draw corpse food image
                        if (corpseImage && corpseImage.complete) {
                            // Create circular clipping area
                            ctx.beginPath();
                            ctx.arc(0, 0, gridSize / 2, 0, Math.PI * 2);
                            ctx.clip();
                            
                            ctx.drawImage(corpseImage, -gridSize/2, -gridSize/2, gridSize, gridSize);
                        } else {
                            // If image not loaded, use default emoji
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = `bold ${gridSize * 0.6}px "Comic Sans MS", cursive`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(corpseFood.meme, 0, 0);
                        }
                        
                        // Restore context
                        ctx.restore();
                    });
                }
                
                // Draw special food (blinking effect)
                if (specialFood) {
                    // Blinking effect
                    const opacity = 0.5 + Math.sin(Date.now() / 100) * 0.5;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = 20;
                    
                    // Rotation animation
                    ctx.save();
                    ctx.translate(specialFood.x + gridSize / 2, specialFood.y + gridSize / 2);
                    ctx.rotate(Date.now() / 500);
                    
                    ctx.beginPath();
                    ctx.rect(-gridSize / 2, -gridSize / 2, gridSize, gridSize);
                    ctx.fill();
                    
                    // Special symbol
                    ctx.fillStyle = 'gold';
                    ctx.font = `${gridSize * 0.7}px "Comic Sans MS", cursive`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(specialFood.meme, 0, 0);
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        // ÂºÄÂßãÊ∏∏Êàè
        function startGame() {
            if (isGameRunning) return;
            
            // È™åËØÅÈí±ÂåÖÂú∞ÂùÄ
            const walletAddress = playerNameInput.value.trim();
            if (!walletAddress) {
                alert('Please enter wallet address!');
                return;
            }
            
            // È™åËØÅÈí±ÂåÖÂú∞ÂùÄÊ†ºÂºè
            if (!walletAddress.match(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)) {
                alert('Please enter a valid Solana wallet address!');
                return;
            }
            
            startScreen.classList.add('hidden');
            pauseBtn.classList.remove('hidden');
            roomSwitchBtn.classList.remove('hidden');
            isGameRunning = true;
            isPaused = true; // Start paused for countdown
            
            // ÂºÄÂßãÊí≠ÊîæËÉåÊôØÈü≥‰πê
            startBackgroundMusic();
            
            // ÂàùÂßãÂåñÊ∏∏Êàè
            initGame();
            
            // Ê†áËÆ∞‰∏∫ÊúâÊïàÁî®Êà∑ÔºàÂ¶ÇÊûú‰ΩøÁî®‰∫ÜÈÇÄËØ∑Á†ÅÔºâ
            loadInviteDataForGame();
            
            // ÊòæÁ§∫ÂÄíËÆ°Êó∂Â±èÂπï
            showCountdownScreen();
        }
        
        // ÊòæÁ§∫ÂÄíËÆ°Êó∂Â±èÂπï
        function showCountdownScreen() {
            const countdownScreen = document.getElementById('countdownScreen');
            const countdownNumber = document.getElementById('countdownNumber');
            
            countdownScreen.classList.remove('hidden');
            
            let count = 3;
            countdownNumber.textContent = count;
            
            // Play countdown sound
            playCountdownSound();
            
            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownNumber.textContent = count;
                    // Reset animation
                    countdownNumber.classList.remove('countdown-animation');
                    void countdownNumber.offsetWidth; // Trigger reflow
                    countdownNumber.classList.add('countdown-animation');
                    // Play countdown sound
                    playCountdownSound();
                } else {
                    // Countdown finished
                    clearInterval(countdownInterval);
                    countdownScreen.classList.add('hidden');
                    
                    // Play start sound
                    playStartSound();
                    
                    // Start the actual game
                    startActualGame();
                }
            }, 1000);
        }
        
        // Êí≠ÊîæÂÄíËÆ°Êó∂Èü≥Êïà
        function playCountdownSound() {
            // Create a simple beep sound using Web Audio API
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (error) {
                console.log('Audio not supported or blocked');
            }
        }
        
        // Êí≠ÊîæÂºÄÂßãÈü≥Êïà
        function playStartSound() {
            // Create a different sound for game start
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.2);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch (error) {
                console.log('Audio not supported or blocked');
            }
        }
        
        // ÂºÄÂßãÂÆûÈôÖÊ∏∏Êàè
        function startActualGame() {
            isPaused = false;
            
            // Á´ãÂç≥ÁªòÂà∂‰∏ÄÊ¨°Ê∏∏ÊàèÁîªÈù¢
            draw();
            
            // Ê£ÄÊü•Ê∏∏ÊàèÁä∂ÊÄÅ
            database.ref('gameState').once('value', (snapshot) => {
                if (snapshot.exists()) {
                    const gameState = snapshot.val();
                    if (gameState.isRunning) {
                        // Ê∏∏ÊàèÊ≠£Âú®ËøêË°åÔºåÂºÄÂßãÊ∏∏ÊàèÂæ™ÁéØ
                        gameLoop = setInterval(gameUpdate, gameSpeed);
                    } else {
                        // Ê∏∏ÊàèË¢´ÊöÇÂÅúÔºåÊòæÁ§∫ÊöÇÂÅúÊ∂àÊÅØ
                        showGamePausedMessage();
                    }
                } else {
                    // Ê≤°ÊúâÊ∏∏ÊàèÁä∂ÊÄÅÔºåÈªòËÆ§ÂºÄÂßã
                    gameLoop = setInterval(gameUpdate, gameSpeed);
                }
            });
        }
        
        // ÂàáÊç¢ÊàøÈó¥
        function switchRoom() {
            if (!isGameRunning) return;
            
            // ÊöÇÂÅúÊ∏∏Êàè
            isPaused = true;
            
            // ÁßªÈô§ÂΩìÂâçÊàøÈó¥ÁöÑÁé©ÂÆ∂Êï∞ÊçÆ
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).remove();
            }
            
            // ÊòæÁ§∫ÊàøÈó¥ÈÄâÊã©
            startScreen.classList.remove('hidden');
            pauseBtn.classList.add('hidden');
            roomSwitchBtn.classList.add('hidden');
            
            // ÂÅúÊ≠¢Ê∏∏ÊàèÂæ™ÁéØ
            clearInterval(gameLoop);
            isGameRunning = false;
            
            // Ê∏ÖÁ©∫Èí±ÂåÖÂú∞ÂùÄËæìÂÖ•Ê°ÜÔºåËÆ©Áî®Êà∑ÈáçÊñ∞ËæìÂÖ•
            playerNameInput.value = '';
        }
        
        // ÊöÇÂÅú/ÁªßÁª≠Ê∏∏Êàè
        function togglePause() {
            if (!isGameRunning) return;
            
            isPaused = !isPaused;
            pauseBtn.innerHTML = isPaused ? 
                '<i class="fa fa-play text-xl"></i>' : 
                '<i class="fa fa-pause text-xl"></i>';
            
            // ÊöÇÂÅú/ÊÅ¢Â§çÈü≥‰πê
            if (isPaused && isMusicPlaying) {
                bgMusic.pause();
            } else if (!isPaused && !isMusicPlaying) {
                bgMusic.play();
            }
        }
        
        // Ê∏∏ÊàèÁªìÊùü
        function gameOver() {
            clearInterval(gameLoop);
            isGameRunning = false;
            gameOverScreen.classList.remove('hidden');
            pauseBtn.classList.add('hidden');
            
            // Â∞ÜÊ≠ª‰∫°ÁöÑËõáË∫´‰ΩìÂèòÊàêÂ∞∏‰ΩìÈ£üÁâ©
            createCorpseFoods();
            
            // Êõ¥Êñ∞Áé©ÂÆ∂Áä∂ÊÄÅ‰∏∫Ê≠ª‰∫°
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).update({
                    alive: false
                });
            }
            
            // ‰øùÂ≠òÊúÄÈ´òÂàÜÂà∞ÊéíË°åÊ¶ú
            saveHighScore();
            
            // Ëé∑ÂèñÂπ∂ÊòæÁ§∫ÂΩìÂâçÊéíË°åÊ¶ú
            database.ref(`rooms/${gameRoom}/leaderboard`).once('value', (snapshot) => {
                const leaderboard = snapshot.val() || [];
                updateLeaderboardDisplay(leaderboard);
            });
            
            // Update total user score
            updateTotalUserScore();
        }
        
        // ÂàõÂª∫Â∞∏‰ΩìÈ£üÁâ©
        function createCorpseFoods() {
            if (snake && snake.length > 0) {
                const gridSize = 15; // Âõ∫ÂÆöÁΩëÊ†ºÂ§ßÂ∞è
                const newCorpseFoods = [];
                
                // ÈöèÊú∫ÈÄâÊã©memeË°®ÊÉÖ
                const memeEmojis = ['üíÄ', '‚ò†Ô∏è', 'üëª', 'ü§°', 'üòµ', 'üí©', 'üî•', '‚ö∞Ô∏è', 'ü™¶', 'üßü'];
                const memeColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'];
                
                // Â∞ÜËõáË∫´‰ΩìÁöÑÊØè‰∏™ÈÉ®ÂàÜÂèòÊàêÂ∞∏‰ΩìÈ£üÁâ©
                snake.forEach((segment, index) => {
                    // Á°Æ‰øùÂ∞∏‰ΩìÈ£üÁâ©Âú®ÊúâÊïàÊ∏∏ÊàèÂå∫ÂüüÂÜÖ
                    const canvasWidth = 1200;
                    const canvasHeight = 960;
                    const margin = Math.floor(canvasWidth * 0.05); // 60pxËæπË∑ù
                    const effectiveWidth = canvasWidth - 2 * margin;
                    const effectiveHeight = canvasHeight - 2 * margin;
                    
                    // ËÆ°ÁÆóÁΩëÊ†ºÂùêÊ†á
                    const gridX = Math.floor((segment.x - margin) / gridSize);
                    const gridY = Math.floor((segment.y - margin) / gridSize);
                    
                    // Á°Æ‰øùÂú®ÊúâÊïàËåÉÂõ¥ÂÜÖ
                    const maxGridX = Math.floor(effectiveWidth / gridSize) - 1;
                    const maxGridY = Math.floor(effectiveHeight / gridSize) - 1;
                    
                    const clampedGridX = Math.max(0, Math.min(gridX, maxGridX));
                    const clampedGridY = Math.max(0, Math.min(gridY, maxGridY));
                    
                    // ËΩ¨Êç¢ÂõûÂÉèÁ¥†ÂùêÊ†á
                    const clampedX = margin + clampedGridX * gridSize;
                    const clampedY = margin + clampedGridY * gridSize;
                    
                    const randomMeme = memeEmojis[Math.floor(Math.random() * memeEmojis.length)];
                    const randomColor = memeColors[Math.floor(Math.random() * memeColors.length)];
                    
                    const corpseFood = {
                        x: clampedX,
                        y: clampedY,
                        color: randomColor, // ÈöèÊú∫memeÈ¢úËâ≤
                        meme: randomMeme,
                        timestamp: Date.now(),
                        id: 'corpse_' + Date.now() + '_' + index,
                        // ÁßªÈô§Áé©ÂÆ∂ÂêçÂ≠óÔºå‰∏çÂÜçÊòæÁ§∫
                        originalColor: playerColor || '#FF3333',
                        rotation: Math.random() * 360, // ÈöèÊú∫ÊóãËΩ¨ËßíÂ∫¶
                        pulse: Math.random() * 2 + 1, // ÈöèÊú∫ËÑâÂÜ≤ÈÄüÂ∫¶
                        wiggle: Math.random() * 10 - 5 // ÈöèÊú∫ÊëÜÂä®ÂπÖÂ∫¶
                    };
                    newCorpseFoods.push(corpseFood);
                });
                
                // Ëé∑ÂèñÁé∞ÊúâÁöÑÂ∞∏‰ΩìÈ£üÁâ©Âπ∂Ê∑ªÂä†Êñ∞ÁöÑ
                database.ref(`rooms/${gameRoom}/corpseFoods`).once('value', (snapshot) => {
                    const existingCorpseFoods = snapshot.val() || [];
                    const allCorpseFoods = [...existingCorpseFoods, ...newCorpseFoods];
                    database.ref(`rooms/${gameRoom}/corpseFoods`).set(allCorpseFoods);
                });
            }
        }
        
        // ‰øùÂ≠òÊúÄÈ´òÂàÜÂà∞ÊéíË°åÊ¶ú
        function saveHighScore() {
            const leaderboardRef = database.ref(`rooms/${gameRoom}/leaderboard`);
            leaderboardRef.once('value', (snapshot) => {
                let leaderboard = snapshot.val() || [];
                
                // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ≠òÂú®ËØ•Áé©ÂÆ∂ÁöÑËÆ∞ÂΩï
                const existingIndex = leaderboard.findIndex(entry => entry.playerId === playerId);
                
                if (existingIndex !== -1) {
                    // Êõ¥Êñ∞Áé∞ÊúâËÆ∞ÂΩï
                    if (score > leaderboard[existingIndex].score) {
                        leaderboard[existingIndex] = {
                            playerId: playerId,
                            playerName: playerName,
                            wallet: playerWallet,
                            score: score,
                            timestamp: Date.now()
                        };
                    }
                } else {
                    // Ê∑ªÂä†Êñ∞ËÆ∞ÂΩï
                    leaderboard.push({
                        playerId: playerId,
                        playerName: playerName,
                        wallet: playerWallet,
                        score: score,
                        timestamp: Date.now()
                    });
                }
                
                // ÊåâÂàÜÊï∞ÈôçÂ∫èÊéíÂ∫è
                leaderboard.sort((a, b) => b.score - a.score);
                
                // Âè™‰øùÁïôÂâç10Âêç
                leaderboard = leaderboard.slice(0, 10);
                
                // ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
                leaderboardRef.set(leaderboard);
            });
        }
        
        // ÊòæÁ§∫È¢ÜÂèñÂ•ñÂä±ÂºπÁ™ó
        function showClaimRewardModal() {
            const modal = document.getElementById('claimRewardModal');
            modal.classList.remove('hidden');
            
            // Â¶ÇÊûúÂΩìÂâçÊúâÁé©ÂÆ∂Èí±ÂåÖÂú∞ÂùÄÔºåËá™Âä®Â°´ÂÖÖ
            if (playerWallet) {
                document.getElementById('walletAddressInput').value = playerWallet;
            }
        }
        
        // ÈöêËóèÈ¢ÜÂèñÂ•ñÂä±ÂºπÁ™ó
        function hideClaimRewardModal() {
            const modal = document.getElementById('claimRewardModal');
            modal.classList.add('hidden');
            document.getElementById('claimResult').classList.add('hidden');
        }
        
        // Êü•ÁúãÁßØÂàÜ
        async function checkScore() {
            const walletAddress = document.getElementById('walletAddressInput').value.trim();
            if (!walletAddress) {
                showClaimResult('Please enter wallet address', 'error');
                return;
            }
            
            try {
                const userRef = database.ref(`users/${walletAddress}`);
                const snapshot = await userRef.once('value');
                const userData = snapshot.val();
                const totalScore = userData ? (userData.score || 0) : 0;
                
                document.getElementById('totalScore').textContent = totalScore;
                document.getElementById('tokenAmount').textContent = totalScore * 10; // 1ÁßØÂàÜ = 10‰ª£Â∏Å
                
                showClaimResult(`Query successful! Wallet ${walletAddress.substring(0, 8)}...${walletAddress.substring(walletAddress.length - 4)} has ${totalScore} points`, 'success');
            } catch (error) {
                showClaimResult('Failed to query points: ' + error.message, 'error');
            }
        }
        
        // ÂÖëÊç¢‰ª£Â∏ÅÔºàÂèåÈáçËΩ¨Ë¥¶ÔºöÁî®Êà∑95% + ÈªëÊ¥û5%Ôºâ
        async function claimToken() {
            const walletAddress = document.getElementById('walletAddressInput').value.trim();
            
            if (!walletAddress) {
                showClaimResult('Please enter wallet address', 'error');
                return;
            }
            
            try {
                showClaimResult('Processing claim request...', 'info');
                
                // Ëé∑ÂèñÁî®Êà∑ÁßØÂàÜ
                const scoreAmount = parseInt(document.getElementById('totalScore').textContent) || 0;
                if (scoreAmount <= 0) {
                    showClaimResult('No points available for claim', 'error');
                    return;
                }
                
                const totalTokenAmount = scoreAmount * 10; // 1ÁßØÂàÜ = 10‰ª£Â∏Å
                const userTokenAmount = Math.floor(totalTokenAmount * 0.95); // 95%ÁªôÁî®Êà∑
                const blackholeTokenAmount = totalTokenAmount - userTokenAmount; // 5%ÁªôÈªëÊ¥û
                
                console.log(`Token distribution plan: Total ${totalTokenAmount}, User ${userTokenAmount}(95%), Blackhole ${blackholeTokenAmount}(5%)`);
                
                // Blackhole address (for testing: user-provided valid Solana address)
                const BLACKHOLE_ADDRESS = '6QHygYqsfancR8uJ4Sez8fugRyUzZQj2KayCyqiLKTPy';
                
                showClaimResult('Step 1/2: Transferring tokens to user...', 'info');
                
                // Step 1: Transfer to user (95%)
                // First temporarily set user score to 95% corresponding score
                const userScore = Math.floor(scoreAmount * 0.95);
                console.log(`Setting user score: ${walletAddress} -> ${userScore}`);
                await setUserScore(walletAddress, userScore);
                
                console.log(`Calling cloud function claimToken, wallet address: ${walletAddress}`);
                const userResult = await claimTokenFunction({ wallet: walletAddress });
                console.log('User transfer complete result:', userResult);
                
                if (!userResult || !userResult.data) {
                    throw new Error('User transfer failed: Cloud function returned empty data');
                }
                
                if (!userResult.data.success) {
                    throw new Error('User transfer failed: ' + (userResult.data.message || 'Unknown error'));
                }
                
                const userTxHash = userResult.data.tx;
                console.log(`User transfer successful, transaction hash: ${userTxHash}`);
                
                showClaimResult('Step 2/2: Burning tokens to blackhole...', 'info');
                
                // Step 2: Transfer to blackhole address (5%)
                // Set blackhole address score to 5% corresponding score
                const blackholeScore = scoreAmount - userScore;
                console.log(`Setting blackhole score: ${BLACKHOLE_ADDRESS} -> ${blackholeScore}`);
                await setUserScore(BLACKHOLE_ADDRESS, blackholeScore);
                
                console.log(`Starting blackhole burn process, amount: ${blackholeScore}`);
                let blackholeTxHash = '';
                
                // Try option 1: Call cloud function for actual transfer
                try {
                    console.log(`Calling cloud function claimToken, blackhole address: ${BLACKHOLE_ADDRESS}`);
                    const blackholeResult = await claimTokenFunction({ wallet: BLACKHOLE_ADDRESS });
                    console.log('Blackhole transfer complete result:', blackholeResult);
                    
                    if (blackholeResult && blackholeResult.data && blackholeResult.data.success) {
                        blackholeTxHash = blackholeResult.data.tx;
                        console.log('‚úÖ Blackhole transfer successful, transaction hash:', blackholeTxHash);
                    } else {
                        throw new Error('Cloud function returned failure status: ' + (blackholeResult?.data?.message || 'Unknown error'));
                    }
                } catch (blackholeError) {
                    console.warn('‚ùå Blackhole transfer call failed:', blackholeError.message);
                    
                    // Option 2: Record burn (no actual transfer, but record burn information)
                    console.log('üîÑ Enabling backup plan: Record burn');
                    try {
                        // Create burn record
                        const burnRecord = {
                            userWallet: walletAddress,
                            burnAmount: blackholeTokenAmount,
                            burnScore: blackholeScore,
                            timestamp: Date.now(),
                            method: 'RECORD_BURN', // Record burn
                            reason: 'CLOUD_FUNCTION_FAILED'
                        };
                        
                        // Save burn record to database
                        await database.ref(`burnRecords/${Date.now()}_${walletAddress.substring(0, 8)}`).set(burnRecord);
                        
                        // Clear blackhole address score
                        await setUserScore(BLACKHOLE_ADDRESS, 0);
                        
                        blackholeTxHash = 'BURN_RECORDED'; // Mark as record burn
                        console.log('‚úÖ Burn record saved, score cleared');
                        
                    } catch (recordError) {
                        console.error('‚ùå Record burn also failed:', recordError);
                        blackholeTxHash = 'BURN_ERROR';
                    }
                }
                
                    // ÈöêËóèÂΩìÂâçÂºπÁ™ó
                    hideClaimRewardModal();
                    
                // ÊûÑÈÄ†ËøîÂõûÊï∞ÊçÆ
                const combinedResult = {
                    success: true,
                    userTxHash: userTxHash,
                    blackholeTxHash: blackholeTxHash,
                    totalTokens: totalTokenAmount,
                    userTokens: userTokenAmount,
                    blackholeTokens: blackholeTokenAmount,
                    message: `Successfully claimed ${totalTokenAmount} tokens. ${userTokenAmount} sent to your wallet, ${blackholeTokenAmount} burned to blackhole.`
                };
                    
                    // ÊòæÁ§∫ÊàêÂäüÂºπÁ™ó
                showSuccessModal(combinedResult, totalTokenAmount);
                    
                // ÂÖëÊç¢ÊàêÂäüÂêéÊ∏ÖÈõ∂Áî®Êà∑ÁßØÂàÜ
                try {
                    await setUserScore(walletAddress, 0);
                    console.log('Cleared user score after successful claim');
                } catch (clearError) {
                    console.error('Failed to clear user score:', clearError);
                }
                    
                // Âà∑Êñ∞ÁßØÂàÜÊòæÁ§∫
                setTimeout(() => {
                    checkScore();
                }, 1000);
                
            } catch (error) {
                console.error('Claim token error:', error);
                showClaimResult('Claim failed: ' + error.message, 'error');
                
                // Â¶ÇÊûúÂÖëÊç¢Â§±Ë¥•ÔºåÊÅ¢Â§çÁî®Êà∑ÁöÑÁ¥ØËÆ°ÁßØÂàÜ
                try {
                    const originalScore = parseInt(document.getElementById('totalScore').textContent) || 0;
                    if (originalScore > 0) {
                        await setUserScore(walletAddress, originalScore);
                        console.log('Restored user score after failed claim');
                    }
                } catch (restoreError) {
                    console.error('Failed to restore user score:', restoreError);
                }
            }
        }
        
        // ËæÖÂä©ÂáΩÊï∞ÔºöËÆæÁΩÆÁî®Êà∑ÁßØÂàÜÔºà‰ªÖÁî®‰∫é‰ª£Â∏ÅÂÖëÊç¢Êó∂ÁöÑ‰∏¥Êó∂ËÆæÁΩÆÔºâ
        async function setUserScore(walletAddress, score) {
            try {
                console.log(`Starting to set temporary score: ${walletAddress.substring(0, 8)}... -> ${score}`);
                
                const userRef = database.ref(`users/${walletAddress}`);
                await userRef.update({
                    score: score,
                    timestamp: Date.now()
                });
                
                // Verify if setting was successful
                const snapshot = await userRef.once('value');
                const userData = snapshot.val();
                console.log(`Temporary score setting successful: ${walletAddress.substring(0, 8)}...`, userData);
                
            } catch (error) {
                console.error('Failed to set user score:', error);
                throw new Error('Failed to set user score: ' + error.message);
            }
        }
        
        // ÊµãËØï‰∫ëÂáΩÊï∞ËøûÊé•
        async function testCloudFunction(walletAddress) {
            try {
                console.log('=== Testing cloud function connection ===');
                console.log(`Test wallet address: ${walletAddress}`);
                
                // Set test score
                await setUserScore(walletAddress, 1);
                
                // Call cloud function
                const result = await claimTokenFunction({ wallet: walletAddress });
                console.log('Cloud function test result:', result);
                
                return result;
            } catch (error) {
                console.error('Cloud function test failed:', error);
                throw error;
            }
        }
        
        // ÊòæÁ§∫ÁªìÊûú‰ø°ÊÅØ
        function showClaimResult(message, type) {
            const resultDiv = document.getElementById('claimResult');
            resultDiv.className = `mt-4 p-3 rounded ${type === 'success' ? 'bg-green-600' : type === 'error' ? 'bg-red-600' : 'bg-blue-600'} text-white`;
            resultDiv.textContent = message;
            resultDiv.classList.remove('hidden');
        }
        
        // Ëé∑ÂèñÈªëÊ¥ûÈîÄÊØÅÁä∂ÊÄÅÊòæÁ§∫
        function getBurnStatusDisplay(txHash) {
            if (!txHash) {
                return `
                    <div class="text-xs text-yellow-400 break-all font-mono">‚ö†Ô∏è ÈªëÊ¥ûËΩ¨Ë¥¶Êú™ÊâßË°å</div>
                    <div class="text-xs text-yellow-400 mt-1">Ê≥®ÊÑèÔºö‰ª£Â∏ÅÊú™ÂÆûÈôÖÈîÄÊØÅ</div>
                `;
            }
            
            if (txHash === 'BURN_FAILED') {
                return `
                    <div class="text-xs text-orange-400 break-all font-mono">‚ùå ÈªëÊ¥ûËΩ¨Ë¥¶Â§±Ë¥•</div>
                    <div class="text-xs text-orange-400 mt-1">‰∫ëÂáΩÊï∞ÊâßË°åÂ§±Ë¥•Ôºå‰ΩÜÁßØÂàÜÂ∑≤Êâ£Èô§</div>
                `;
            }
            
            if (txHash === 'BURN_ERROR') {
                return `
                    <div class="text-xs text-red-400 break-all font-mono">üö´ ÈªëÊ¥ûËΩ¨Ë¥¶ÈîôËØØ</div>
                    <div class="text-xs text-red-400 mt-1">ÁΩëÁªúÈîôËØØÊàñÂú∞ÂùÄÊó†ÊïàÔºåÁßØÂàÜÂ∑≤ÈáçÁΩÆ</div>
                `;
            }
            
            if (txHash === 'BURN_RECORDED') {
                return `
                    <div class="text-xs text-blue-400 break-all font-mono">üìù ËÆ∞ÂΩïÂºèÈîÄÊØÅ</div>
                    <div class="text-xs text-blue-400 mt-1">‚úÖ ÈîÄÊØÅËÆ∞ÂΩïÂ∑≤‰øùÂ≠òÔºåÁßØÂàÜÂ∑≤Êâ£Èô§</div>
                `;
            }
            
            // Ê≠£Â∏∏ÁöÑ‰∫§ÊòìÂìàÂ∏å
            return `
                <div class="text-xs text-red-400 break-all font-mono">${txHash}</div>
                                            <div class="text-xs text-green-400 mt-1">‚úÖ Token successfully destroyed</div>
            `;
        }
        
        // ÊòæÁ§∫ÂÖëÊç¢ÊàêÂäüÂºπÁ™ó
        function showSuccessModal(result, amount) {
            // ÂàõÂª∫ÊàêÂäüÂºπÁ™ó
            const successModal = document.createElement('div');
            successModal.className = 'fixed inset-0 bg-black/80 flex items-center justify-center z-50';
            
            // ËÆ°ÁÆóÂÆûÈôÖÂèëÈÄÅÁªôÁî®Êà∑ÁöÑ‰ª£Â∏ÅÊï∞ÈáèÔºà95%Ôºâ
            const userAmount = Math.floor(amount * 0.95);
            const blackholeAmount = amount - userAmount;
            
            successModal.innerHTML = `
                <div class="bg-gray-800 p-6 rounded-lg border-2 border-memeGreen max-w-md w-full mx-4">
                    <div class="text-center">
                        <div class="text-6xl mb-4">üéâ</div>
                        <h3 class="text-2xl font-bold text-memeGreen mb-4">Claim Successful!</h3>
                        
                        <!-- Áî®Êà∑Ëé∑ÂæóÁöÑ‰ª£Â∏Å -->
                        <div class="mb-4 p-3 bg-gray-700 rounded">
                            <div class="text-lg font-bold text-memeYellow mb-2">${userAmount} Tokens</div>
                            <div class="text-sm text-gray-400">Sent to your wallet (95%)</div>
                        </div>
                        
                        <!-- ÈªëÊ¥ûÈîÄÊØÅÁöÑ‰ª£Â∏Å -->
                        <div class="mb-4 p-3 bg-gray-700 rounded border border-red-500">
                            <div class="text-lg font-bold text-red-400 mb-2">üî• ${blackholeAmount} Tokens Burned</div>
                            <div class="text-sm text-gray-400">Sent to blackhole address (5%)</div>
                        </div>
                        
                        <!-- Áî®Êà∑ËΩ¨Ë¥¶ÂìàÂ∏å -->
                        <div class="mb-4 p-3 bg-gray-700 rounded text-left">
                            <div class="text-sm text-gray-400 mb-1">User Transaction Hash:</div>
                            <div class="text-xs text-memeBlue break-all font-mono">${result.userTxHash || result.tx || 'N/A'}</div>
                        </div>
                        
                        <!-- ÈªëÊ¥ûËΩ¨Ë¥¶ÂìàÂ∏å -->
                        <div class="mb-4 p-3 bg-gray-700 rounded text-left border border-red-500">
                            <div class="text-sm text-red-400 mb-1">Blackhole Transaction Hash:</div>
                            ${getBurnStatusDisplay(result.blackholeTxHash || result.blackholeTx)}
                        </div>
                        
                        <div class="mb-4 text-sm text-gray-400">
                            You can view transaction details in Solana Explorer
                        </div>
                        <button class="bg-memeGreen hover:bg-memeGreen/80 text-black py-2 px-6 rounded font-bold" onclick="this.parentElement.parentElement.parentElement.remove()">
                            OK
                        </button>
                    </div>
                </div>
            `;
            
            // Ê∑ªÂä†Âà∞È°µÈù¢
            document.body.appendChild(successModal);
            
            // ÁÇπÂáªËÉåÊôØÂÖ≥Èó≠ÂºπÁ™ó
            successModal.addEventListener('click', (e) => {
                if (e.target === successModal) {
                    successModal.remove();
                }
            });
        }
        
        // ÈáçÂêØÊ∏∏Êàè
        function restartGame() {
            // Ê∏ÖÈô§Ê∏∏ÊàèÂæ™ÁéØ
            clearInterval(gameLoop);
            
            // ÈáçÁΩÆÊ∏∏ÊàèÁä∂ÊÄÅ
            isGameRunning = false;
            isPaused = false;
            
            // ÈöêËóèÊ∏∏ÊàèÁªìÊùüÂ±èÂπï
            gameOverScreen.classList.add('hidden');
            
            // ÁßªÈô§ÂΩìÂâçÊàøÈó¥ÁöÑÁé©ÂÆ∂Êï∞ÊçÆ
            if (playerId) {
                database.ref(`rooms/${gameRoom}/players/${playerId}`).remove();
            }
            
            // ÈáçÊñ∞ÂºÄÂßãÊ∏∏ÊàèÔºàÂåÖÂê´ÂÄíËÆ°Êó∂Ôºâ
            startGame();
        }
        
        // Â§ÑÁêÜÈîÆÁõòËæìÂÖ•
        function handleKeyPress(e) {
            // ÈòªÊ≠¢ÊñπÂêëÈîÆÊªöÂä®È°µÈù¢
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
            
            // Âè™Âú®Ê∏∏ÊàèËøêË°åÊó∂Â§ÑÁêÜÊñπÂêëÈîÆÔºåÊàñËÄÖÂ§ÑÁêÜÁ©∫Ê†ºÈîÆ
            if (!isGameRunning && e.key !== ' ') return;
            
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction !== 'down') {
                        nextDirection = 'up';
                    }
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction !== 'up') {
                        nextDirection = 'down';
                    }
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction !== 'right') {
                        nextDirection = 'left';
                    }
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction !== 'left') {
                        nextDirection = 'right';
                    }
                    break;
                case ' ': // Á©∫Ê†ºÈîÆÊöÇÂÅú/ÁªßÁª≠
                    if (isGameRunning) {
                        togglePause();
                    } else if (!startScreen.classList.contains('hidden')) {
                        startGame();
                    }
                    break;
            }
        }
        
        // Èü≥‰πêÊéßÂà∂ÂáΩÊï∞
        function startBackgroundMusic() {
            if (bgMusic && !isMusicPlaying) {
                bgMusic.volume = musicVolume;
                bgMusic.play().then(() => {
                    isMusicPlaying = true;
                    updateMusicUI();
                }).catch(error => {
                    console.log('Music autoplay failed:', error);
                    // Áî®Êà∑‰∫§‰∫íÂêéÂèØ‰ª•Êí≠ÊîæÈü≥‰πê
                });
            }
        }
        
        function toggleMusic() {
            if (!bgMusic) return;
            
            if (isMusicPlaying) {
                bgMusic.pause();
                isMusicPlaying = false;
            } else {
                bgMusic.play();
                isMusicPlaying = true;
            }
            updateMusicUI();
        }
        
        function updateMusicUI() {
            if (!musicBtn || !musicIndicator) return;
            
            if (isMusicPlaying) {
                musicBtn.innerHTML = '<i class="fa fa-music"></i>';
                musicBtn.classList.remove('muted');
                musicIndicator.classList.remove('muted');
            } else {
                musicBtn.innerHTML = '<i class="fa fa-volume-off"></i>';
                musicBtn.classList.add('muted');
                musicIndicator.classList.add('muted');
            }
        }
        
        function setMusicVolume(volume) {
            musicVolume = Math.max(0, Math.min(1, volume));
            if (bgMusic) {
                bgMusic.volume = musicVolume;
            }
        }
        
        function setSoundVolume(volume) {
            soundVolume = Math.max(0, Math.min(1, volume));
            if (eatSound) {
                eatSound.volume = soundVolume;
            }
        }
        
        function playEatSound() {
            if (eatSound) {
                eatSound.volume = soundVolume;
                eatSound.currentTime = 0; // ÈáçÁΩÆÊí≠Êîæ‰ΩçÁΩÆ
                eatSound.play().catch(error => {
                    console.log('Sound effect play failed:', error);
                });
            }
        }
        
        // ÂàùÂßãÂåñÈü≥‰πêÊéßÂà∂
        function initMusicControl() {
            if (musicBtn) {
                musicBtn.addEventListener('click', toggleMusic);
            }
            
            // ËÆæÁΩÆÂàùÂßãÈü≥Èáè
            setMusicVolume(0.5);
            setSoundVolume(0.7);
            
            // Êõ¥Êñ∞UIÁä∂ÊÄÅ
            updateMusicUI();
        }
        
        // ÈÇÄËØ∑Á≥ªÁªüÂáΩÊï∞
        function generateInviteCode(walletAddress) {
            // ‰ΩøÁî®Èí±ÂåÖÂú∞ÂùÄÁöÑÂêé8‰Ωç‰Ωú‰∏∫ÈÇÄËØ∑Á†Å
            return walletAddress.slice(-8);
        }
        
        function showInviteModal() {
            const modal = document.getElementById('inviteModal');
            if (modal) {
                modal.classList.remove('hidden');
                loadInviteData();
                
                // ÈöêËóèÈ¢ÜÂèñÂ•ñÂä±ÂºπÁ™ó
                hideClaimRewardModal();
            }
        }
        
        function closeInviteModal() {
            const modal = document.getElementById('inviteModal');
            if (modal) {
                modal.classList.add('hidden');
                
                // ÈáçÊñ∞ÊòæÁ§∫È¢ÜÂèñÂ•ñÂä±ÂºπÁ™ó
                showClaimRewardModal();
            }
        }
        
        function loadInviteData() {
            // Get wallet address from wallet address input field
            const walletAddressInput = document.getElementById('walletAddressInput');
            const walletAddress = walletAddressInput.value.trim();
            
            if (!walletAddress || walletAddress.length < 8) {
                // If wallet address is empty or too short, show prompt
                document.getElementById('myInviteCode').textContent = 'Please enter wallet address first';
                document.getElementById('invitedCount').textContent = '0';
                document.getElementById('bonusPercent').textContent = '0%';
                document.getElementById('inviteStatus').textContent = 'Please enter wallet address in the claim rewards interface first';
                return;
            }
            
            // Generate invite code
            inviteData.myInviteCode = generateInviteCode(walletAddress);
            document.getElementById('myInviteCode').textContent = inviteData.myInviteCode;
            
            // Load invite data from database
            database.ref(`invites/${walletAddress}`).once('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    inviteData = { ...inviteData, ...data };
                } else {
                    // If no data, initialize default values
                    inviteData = {
                        myInviteCode: inviteData.myInviteCode,
                        invitedBy: null,
                        invitedUsers: [],
                        inviteBonus: 0,
                        hasUsedInviteCode: false,
                        isValidUser: false
                    };
                }
                updateInviteUI();
            });
        }
        
        function updateInviteUI() {
            // Update invite stats
            document.getElementById('invitedCount').textContent = inviteData.invitedUsers.length;
            document.getElementById('bonusPercent').textContent = inviteData.inviteBonus + '%';
            
            // Update status information
            const statusEl = document.getElementById('inviteStatus');
            if (inviteData.hasUsedInviteCode) {
                if (inviteData.isValidUser) {
                    statusEl.textContent = `Used invite code: ${inviteData.invitedBy}, already a valid user`;
                } else {
                    statusEl.textContent = `Used invite code: ${inviteData.invitedBy}, will become valid user after starting game`;
                }
            } else {
                statusEl.textContent = 'No invite code used yet';
            }
            
            // If already used invite code, disable input field
            const inviteInput = document.getElementById('inviteCodeInput');
            const submitBtn = document.getElementById('submitInviteBtn');
            if (inviteData.hasUsedInviteCode) {
                inviteInput.disabled = true;
                inviteInput.placeholder = 'Already used invite code';
                submitBtn.disabled = true;
                submitBtn.textContent = 'Submitted';
            }
        }
        
        function copyInviteCode() {
            const inviteCode = inviteData.myInviteCode;
            if (navigator.clipboard) {
                navigator.clipboard.writeText(inviteCode).then(() => {
                    showMessage('Invite code copied to clipboard!');
                }).catch(() => {
                    fallbackCopyTextToClipboard(inviteCode);
                });
            } else {
                fallbackCopyTextToClipboard(inviteCode);
            }
        }
        
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                showMessage('Invite code copied to clipboard!');
            } catch (err) {
                showMessage('Copy failed, please manually copy the invite code');
            }
            document.body.removeChild(textArea);
        }
        
        function submitInviteCode() {
            const inviteCodeInput = document.getElementById('inviteCodeInput');
            const inviteCode = inviteCodeInput.value.trim().toUpperCase();
            
            // Get wallet address from wallet address input field
            const walletAddressInput = document.getElementById('walletAddressInput');
            const walletAddress = walletAddressInput.value.trim();
            
            if (!walletAddress || walletAddress.length < 8) {
                showMessage('Please enter wallet address in the claim rewards interface first');
                return;
            }
            
            if (!inviteCode) {
                showMessage('Please enter invite code');
                return;
            }
            
            if (inviteCode.length !== 8) {
                showMessage('Invite code must be 8 digits');
                return;
            }
            
            if (inviteCode === inviteData.myInviteCode) {
                showMessage('Cannot use your own invite code');
                return;
            }
            
            if (inviteData.hasUsedInviteCode) {
                showMessage('Already used an invite code');
                return;
            }
            
            // Find inviter
            database.ref('players').orderByChild('wallet').once('value', (snapshot) => {
                let inviterFound = false;
                let inviterWallet = '';
                
                snapshot.forEach((childSnapshot) => {
                    const playerData = childSnapshot.val();
                    if (playerData.wallet && generateInviteCode(playerData.wallet) === inviteCode) {
                        inviterFound = true;
                        inviterWallet = playerData.wallet;
                        return true; // break
                    }
                });
                
                if (inviterFound) {
                    // Check inviter's invite limit
                    database.ref(`invites/${inviterWallet}`).once('value', (inviterSnapshot) => {
                        const inviterData = inviterSnapshot.val() || { invitedUsers: [] };
                        
                        if (inviterData.invitedUsers.length >= 30) {
                            showMessage('This invite code has reached the invite limit');
                            return;
                        }
                        
                        // Record invite relationship
                        inviteData.invitedBy = inviteCode;
                        inviteData.hasUsedInviteCode = true;
                        
                        // Save to database
                        database.ref(`invites/${walletAddress}`).set(inviteData);
                        
                        // Update inviter's data
                        inviterData.invitedUsers.push(walletAddress);
                        inviterData.inviteBonus = Math.min(inviterData.invitedUsers.length * 10, 300); // Max 300% bonus
                        database.ref(`invites/${inviterWallet}`).set(inviterData);
                        
                        showMessage('Invite code submitted successfully! You will become a valid user after starting the game');
                        updateInviteUI();
                    });
                } else {
                    showMessage('Invalid invite code');
                }
            });
        }
        
        function showMessage(message) {
            // ÁÆÄÂçïÁöÑÊ∂àÊÅØÊòæÁ§∫ÔºåÂèØ‰ª•ÂêéÁª≠ÊîπËøõ‰∏∫Êõ¥Â•ΩÁöÑUI
            alert(message);
        }
        
        function loadInviteDataForGame() {
            // Get wallet address from wallet address input field
            const walletAddressInput = document.getElementById('walletAddressInput');
            const walletAddress = walletAddressInput.value.trim();
            
            if (!walletAddress || walletAddress.length < 8) {
                return;
            }
            
            // Load invite data from database
            database.ref(`invites/${walletAddress}`).once('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    inviteData = { ...inviteData, ...data };
                    
                    // If used invite code but not yet a valid user, mark as valid user
                    if (data.hasUsedInviteCode && !data.isValidUser) {
                        inviteData.isValidUser = true;
                        database.ref(`invites/${walletAddress}`).set(inviteData);
                        
                        // Update inviter's bonus
                        updateInviterBonus(data.invitedBy, walletAddress);
                    }
                }
            });
        }
        
        function updateInviterBonus(inviteCode, userWallet) {
            if (!inviteCode) return;
            
            // Find inviter wallet address
            database.ref('players').orderByChild('wallet').once('value', (snapshot) => {
                snapshot.forEach((childSnapshot) => {
                    const playerData = childSnapshot.val();
                    if (playerData.wallet && generateInviteCode(playerData.wallet) === inviteCode) {
                        const inviterWallet = playerData.wallet;
                        
                        // Update inviter's bonus
                        database.ref(`invites/${inviterWallet}`).once('value', (inviterSnapshot) => {
                            const inviterData = inviterSnapshot.val() || { invitedUsers: [] };
                            
                            // Calculate valid user count
                            let validUserCount = 0;
                            const promises = inviterData.invitedUsers.map(userWallet => {
                                return database.ref(`invites/${userWallet}`).once('value');
                            });
                            
                            Promise.all(promises).then(snapshots => {
                                snapshots.forEach(userSnapshot => {
                                    const userData = userSnapshot.val();
                                    if (userData && userData.isValidUser) {
                                        validUserCount++;
                                    }
                                });
                                
                                // Update inviter's bonus (10% per valid user, max 300%)
                                inviterData.inviteBonus = Math.min(validUserCount * 10, 300);
                                database.ref(`invites/${inviterWallet}`).set(inviterData);
                            });
                        });
                        
                        return true; // break
                    }
                });
            });
        }
        
        function markAsValidUser() {
            // Get wallet address from wallet address input field
            const walletAddressInput = document.getElementById('walletAddressInput');
            const walletAddress = walletAddressInput.value.trim();
            
            if (!walletAddress || !inviteData.hasUsedInviteCode || inviteData.isValidUser) {
                return;
            }
            
            // Mark as valid user
            inviteData.isValidUser = true;
            database.ref(`invites/${walletAddress}`).set(inviteData);
            
            // If there's an inviter, update inviter's bonus
            if (inviteData.invitedBy) {
                // Find inviter wallet address
                database.ref('players').orderByChild('wallet').once('value', (snapshot) => {
                    snapshot.forEach((childSnapshot) => {
                        const playerData = childSnapshot.val();
                        if (playerData.wallet && generateInviteCode(playerData.wallet) === inviteData.invitedBy) {
                            const inviterWallet = playerData.wallet;
                            
                            // Update inviter's bonus
                            database.ref(`invites/${inviterWallet}`).once('value', (inviterSnapshot) => {
                                const inviterData = inviterSnapshot.val() || { invitedUsers: [] };
                                
                                // Calculate valid user count
                                let validUserCount = 0;
                                const promises = inviterData.invitedUsers.map(userWallet => {
                                    return database.ref(`invites/${userWallet}`).once('value');
                                });
                                
                                Promise.all(promises).then(snapshots => {
                                    snapshots.forEach(userSnapshot => {
                                        const userData = userSnapshot.val();
                                        if (userData && userData.isValidUser) {
                                            validUserCount++;
                                        }
                                    });
                                    
                                    // Update inviter's bonus (10% per valid user, max 300%)
                                    inviterData.inviteBonus = Math.min(validUserCount * 10, 300);
                                    database.ref(`invites/${inviterWallet}`).set(inviteData);
                                });
                            });
                            
                            return true; // break
                        }
                    });
                });
            }
        }
        
        // ‰∫ã‰ª∂ÁõëÂê¨
        document.addEventListener('keydown', handleKeyPress);
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', restartGame);
        pauseBtn.addEventListener('click', togglePause);
        roomSwitchBtn.addEventListener('click', switchRoom);
        
        // È¢ÜÂèñÂ•ñÂä±Áõ∏ÂÖ≥‰∫ã‰ª∂ÁõëÂê¨
        document.getElementById('claimRewardBtn').addEventListener('click', showClaimRewardModal);
        document.getElementById('closeClaimModal').addEventListener('click', hideClaimRewardModal);
        document.getElementById('checkScoreBtn').addEventListener('click', checkScore);
        document.getElementById('claimTokenBtn').addEventListener('click', claimToken);
        document.getElementById('inviteSystemBtn').addEventListener('click', showInviteModal);
        
        // ÊéíË°åÊ¶úÁõ∏ÂÖ≥‰∫ã‰ª∂ÁõëÂê¨
        document.getElementById('viewLeaderboardBtn').addEventListener('click', showLeaderboardModal);
        document.getElementById('closeLeaderboardModal').addEventListener('click', hideLeaderboardModal);
        document.getElementById('refreshLeaderboardBtn').addEventListener('click', loadGlobalLeaderboard);
        
        // ÈÇÄËØ∑Á≥ªÁªü‰∫ã‰ª∂ÁõëÂê¨Âô®
        document.getElementById('closeInviteModal').addEventListener('click', closeInviteModal);
        document.getElementById('copyInviteBtn').addEventListener('click', copyInviteCode);
        document.getElementById('submitInviteBtn').addEventListener('click', submitInviteCode);
        document.getElementById('leaderboardRoomSelect').addEventListener('change', loadGlobalLeaderboard);
        
        // È¢úËâ≤ÈÄâÊã©
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // ÁßªÈô§ÂÖ∂‰ªñÊåâÈíÆÁöÑÈÄâ‰∏≠Áä∂ÊÄÅ
                document.querySelectorAll('.color-btn').forEach(b => {
                    b.classList.remove('border-white');
                    b.classList.add('border-gray-600');
                });
                
                // ÈÄâ‰∏≠ÂΩìÂâçÊåâÈíÆ
                btn.classList.remove('border-gray-600');
                btn.classList.add('border-white');
                
                // ‰øùÂ≠òÈÄâÊã©ÁöÑÈ¢úËâ≤
                playerColor = btn.dataset.color;
            });
        });
        
        // ‰∏çÈ¢ÑÂ°´ÂÖÖÈí±ÂåÖÂú∞ÂùÄÔºåËÆ©Áî®Êà∑ÂøÖÈ°ªËæìÂÖ•
        playerNameInput.value = '';
        
        // ÈªòËÆ§ÈÄâÊã©Á¨¨‰∏Ä‰∏™È¢úËâ≤
        document.querySelector('.color-btn').click();
        
        // Initialize room player counts and set up real-time updates
        updateRoomPlayerCounts();
        
        // Set up real-time room player count updates
        const rooms = ['default', 'room1', 'room2', 'room3'];
        rooms.forEach(roomName => {
            database.ref(`rooms/${roomName}/players`).on('value', () => {
                updateRoomPlayerCounts();
            });
        });
        
        // ÊéíË°åÊ¶úÂäüËÉΩÂáΩÊï∞
        function showLeaderboardModal() {
            const modal = document.getElementById('leaderboardModal');
            modal.classList.remove('hidden');
            loadGlobalLeaderboard();
        }
        
        function hideLeaderboardModal() {
            const modal = document.getElementById('leaderboardModal');
            modal.classList.add('hidden');
        }
        
        async function loadGlobalLeaderboard() {
            const roomSelect = document.getElementById('leaderboardRoomSelect');
            const selectedRoom = roomSelect.value;
            const leaderboardList = document.getElementById('globalLeaderboardList');
            
            // ÊòæÁ§∫Âä†ËΩΩÁä∂ÊÄÅ
            leaderboardList.innerHTML = '<div class="text-center text-gray-400">Loading leaderboard...</div>';
            
            try {
                let allLeaderboards = [];
                
                if (selectedRoom === 'all') {
                    // Ëé∑ÂèñÊâÄÊúâÊàøÈó¥ÁöÑÊéíË°åÊ¶ú
                    const rooms = ['default', 'room1', 'room2', 'room3'];
                    const promises = rooms.map(room => 
                        database.ref(`rooms/${room}/leaderboard`).once('value')
                    );
                    
                    const results = await Promise.all(promises);
                    results.forEach((snapshot, index) => {
                        const leaderboard = snapshot.val() || [];
                        // ‰∏∫ÊØè‰∏™Êù°ÁõÆÊ∑ªÂä†ÊàøÈó¥‰ø°ÊÅØ
                        leaderboard.forEach(entry => {
                            entry.room = rooms[index];
                        });
                        allLeaderboards = allLeaderboards.concat(leaderboard);
                    });
                } else {
                    // Ëé∑ÂèñÁâπÂÆöÊàøÈó¥ÁöÑÊéíË°åÊ¶ú
                    const snapshot = await database.ref(`rooms/${selectedRoom}/leaderboard`).once('value');
                    const leaderboard = snapshot.val() || [];
                    leaderboard.forEach(entry => {
                        entry.room = selectedRoom;
                    });
                    allLeaderboards = leaderboard;
                }
                
                // ÊåâÂàÜÊï∞ÈôçÂ∫èÊéíÂ∫è
                allLeaderboards.sort((a, b) => b.score - a.score);
                
                // Âè™ÊòæÁ§∫Ââç20Âêç
                allLeaderboards = allLeaderboards.slice(0, 20);
                
                // ÊòæÁ§∫ÊéíË°åÊ¶ú
                displayGlobalLeaderboard(allLeaderboards);
                
            } catch (error) {
                console.error('Failed to load leaderboard:', error);
                leaderboardList.innerHTML = '<div class="text-center text-red-400">Failed to load leaderboard</div>';
            }
        }
        
        function displayGlobalLeaderboard(leaderboard) {
            const leaderboardList = document.getElementById('globalLeaderboardList');
            leaderboardList.innerHTML = '';
            
            if (leaderboard.length === 0) {
                leaderboardList.innerHTML = '<div class="text-center text-gray-400">No scores yet</div>';
                return;
            }
            
            leaderboard.forEach((entry, index) => {
                const row = document.createElement('div');
                row.className = 'grid grid-cols-4 gap-4 items-center py-2 border-b border-gray-600';
                
                // ËÆæÁΩÆÊéíÂêçÊ†∑Âºè
                let rankClass = 'text-gray-400';
                if (index === 0) rankClass = 'text-memeYellow font-bold';
                else if (index === 1) rankClass = 'text-gray-300 font-bold';
                else if (index === 2) rankClass = 'text-amber-700 font-bold';
                
                // Ê†ºÂºèÂåñÊó∂Èó¥ (UTC)
                const date = new Date(entry.timestamp);
                const timeStr = `${date.getUTCMonth() + 1}/${date.getUTCDate()} ${date.getUTCHours()}:${date.getUTCMinutes().toString().padStart(2, '0')} UTC`;
                
                // Ê†ºÂºèÂåñÈí±ÂåÖÂú∞ÂùÄ
                const shortWallet = entry.wallet ? 
                    `${entry.wallet.substring(0, 6)}...${entry.wallet.substring(entry.wallet.length - 4)}` : 
                    'Unknown';
                
                // ÊàøÈó¥ÂêçÁß∞Êò†Â∞Ñ
                const roomNames = {
                    'default': 'Default',
                    'room1': 'Beginner',
                    'room2': 'Advanced',
                    'room3': 'Casual'
                };
                
                row.innerHTML = `
                    <div class="${rankClass} text-center">#${index + 1}</div>
                    <div class="text-white">
                        <div class="font-bold">${entry.playerName}</div>
                        <div class="text-xs text-gray-400">${shortWallet} ‚Ä¢ ${roomNames[entry.room] || entry.room}</div>
                    </div>
                    <div class="text-memeGreen font-bold text-center">${entry.score}</div>
                    <div class="text-gray-400 text-center text-sm">${timeStr}</div>
                `;
                
                leaderboardList.appendChild(row);
            });
        }
        
        // È°µÈù¢Âä†ËΩΩÊó∂ÂàùÂßãÂåñÊéíË°åÊ¶ú
        document.addEventListener('DOMContentLoaded', () => {
            // ÂàùÂßãÂåñÈü≥‰πêÊéßÂà∂
            initMusicControl();
            
            // ÂÖ∂‰ªñÂàùÂßãÂåñ‰ª£Á†Å...
        });
        
        // Update room player counts
        function updateRoomPlayerCounts() {
            const rooms = ['default', 'room1', 'room2', 'room3'];
            const roomSelect = document.getElementById('roomSelect');
            
            rooms.forEach(roomName => {
                database.ref(`rooms/${roomName}/players`).once('value', (snapshot) => {
                    const players = snapshot.val() || {};
                    const playerCount = Object.keys(players).length;
                    
                    // Update the corresponding option in the select
                    const option = roomSelect.querySelector(`option[value="${roomName}"]`);
                    if (option) {
                        const roomNames = {
                            'default': 'Default Room',
                            'room1': 'Room 1 - Beginner',
                            'room2': 'Room 2 - Advanced',
                            'room3': 'Room 3 - Casual'
                        };
                        const displayName = roomNames[roomName] || roomName;
                        option.textContent = `${displayName} (${playerCount}/10)`;
                        
                        // Add visual indication if room is full
                        if (playerCount >= 10) {
                            option.style.color = '#ff4444';
                            option.textContent += ' [FULL]';
                        } else {
                            option.style.color = '#ffffff';
                        }
                    }
                });
            });
        }
    </script>
</body>
</html>
